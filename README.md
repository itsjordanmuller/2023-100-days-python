# 100 Days of Python

Self-Paced Learning Sandbox for Python with NumPy, Pandas, Jupyter, Flask, matplotlib, Plotly, scikit-learn, SQLite, SQLAlchemy, Environment Variables, PyPi, Virtual Environments, ESLint, Prettier, Black Formatter, Visual Studio Code, Git & GitHub

![Python](https://img.shields.io/badge/Python-3776AB.svg?style=for-the-badge&logo=Python&logoColor=white)
![NumPy](https://img.shields.io/badge/NumPy-013243.svg?style=for-the-badge&logo=NumPy&logoColor=white)
![Pandas](https://img.shields.io/badge/pandas-150458.svg?style=for-the-badge&logo=pandas&logoColor=white)
![Jupyter](https://img.shields.io/badge/Jupyter-F37626.svg?style=for-the-badge&logo=Jupyter&logoColor=white)
![Flask](https://img.shields.io/badge/Flask-000000.svg?style=for-the-badge&logo=Flask&logoColor=white)
![matplotlib](https://img.shields.io/badge/matplotlib-11557C.svg?style=for-the-badge&logoColor=white)
![Plotly](https://img.shields.io/badge/Plotly-3F4F75.svg?style=for-the-badge&logo=Plotly&logoColor=white)
![scikit-learn](https://img.shields.io/badge/scikitlearn-F7931E.svg?style=for-the-badge&logo=scikit-learn&logoColor=white)
![SQLite](https://img.shields.io/badge/SQLite-003B57.svg?style=for-the-badge&logo=SQLite&logoColor=white)
![SQLAlchemy](https://img.shields.io/badge/SQLAlchemy-D71F00.svg?style=for-the-badge&logo=SQLAlchemy&logoColor=white)
![.env](https://img.shields.io/badge/.ENV-ECD53F.svg?style=for-the-badge&logo=dotenv&logoColor=black)
![PyPI](https://img.shields.io/badge/PyPI-3775A9.svg?style=for-the-badge&logo=PyPI&logoColor=white)
![HTML5](https://img.shields.io/badge/HTML5-E34F26.svg?style=for-the-badge&logo=HTML5&logoColor=white)
![CSS3](https://img.shields.io/badge/CSS3-1572B6.svg?style=for-the-badge&logo=CSS3&logoColor=white)
![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E.svg?style=for-the-badge&logo=JavaScript&logoColor=black)
![ESLint](https://img.shields.io/badge/ESLint-4B32C3.svg?style=for-the-badge&logo=ESLint&logoColor=white)
![Prettier](https://img.shields.io/badge/Prettier-F7B93E.svg?style=for-the-badge&logo=Prettier&logoColor=black)
![Black](https://img.shields.io/badge/Black-000000.svg?style=for-the-badge&logoColor=white)
![Visual Studio Code](https://img.shields.io/badge/Visual%20Studio%20Code-007ACC.svg?style=for-the-badge&logo=Visual-Studio-Code&logoColor=white)
![Git](https://img.shields.io/badge/Git-F05032.svg?style=for-the-badge&logo=Git&logoColor=white)
![GitHub](https://img.shields.io/badge/GitHub-181717.svg?style=for-the-badge&logo=GitHub&logoColor=white)

## Day 1

### Projects (Day 1)

#### [1. Band Name Generator](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-001/Projects/band-name-generator.py)

### Exercises (Day 1)

#### [A. Hello World](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-001/Exercises/0-hello-world.py)

In this exercise, I learned about handling user input, string manipulation, and outputting data. I used the `input()` function to prompt for and receive the user's name. This taught me how to interact with users and capture their responses in a program.

Next, I used the `len()` function to calculate the length of the entered name, which showed me how to work with string properties and perform basic calculations. Finally, I printed both the name and its length to the console, reinforcing my understanding of how to display output in Python.

#### [B. Printing](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-001/Exercises/1-printing.py)

This exercise involved printing text to the console, a fundamental skill in many language, not just Python. I learned how to structure the `print` function and the syntax for outputting strings.

I printed multiple lines, each demonstrating a different aspect of the print function. Starting with a basic introduction line, I moved on to describe how the function is declared, and then displayed an example of the `print` function in action. This helped me understand the basics of displaying text in Python, a key component in many programming tasks.

#### [C. Debugging Practice](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-001/Exercises/2-debugging-practice.py)

In this exercise, I focused on debugging Python code, specifically addressing syntax errors in string manipulation and print statements. I encountered issues like a missing quotation mark, inconsistent use of single and double quotes, and an indentation error.

By correcting these errors, I practiced paying close attention to syntax details, the nuances between single and double quotes, and how proper indentation is crucial. This task was a practical lesson in troubleshooting and refining my understanding of Python syntax, particularly in relation to string handling and output formatting.

#### [D. Input Function](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-001/Exercises/3-input-function.py)

In this exercise, I learned to use the `input()` function to capture user input and the `len()` function to calculate the length of a string.

The program first prompts the user to enter their name, storing the response in variable `a`. Then, it calculates and prints the length of the inputted name using `len(a)`.

This demonstrated how to interact with users and process their input, as well as basic string manipulation.

#### [E. Variables](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-001/Exercises/4-variables.py)

The challenge of this exercise was to swap the values of two variables without altering the given input and output code sections.

Initially, the program collected user inputs for variables `a` and `b`. My task was to write code in the designated area to swap the values of these two variables.

To achieve this, I introduced two new variables, `export_a` and `export_b`, to temporarily hold the values of `a` and `b`. Then, I reassigned the values of a and b by swapping them using the temporary variables.

The final output then reflected the swapped values, demonstrating successful variable manipulation. Through this exercise, I learned a practical application of variables.

## Day 2

### Projects (Day 2)

#### [2. Tip Calculator](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-002/Projects/tip-calculator.py)

### Exercises (Day 2)

#### [A. Primitive Data Types](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-002/Exercises/0-primitive-data-types.py)

In this exercise, I focused on different primitive data types and their operations. I worked with strings, accessing and manipulating characters, integers and floats, performing basic arithmetic operations, and understanding the nuances of different number types.

A significant part of the exercise was learning about type conversion, such as changing integers to strings or strings to floats. I used the `type()` function for identifying data types. The exercise also covered Python's order of operations (PEMDAS), including standard division, floor division, and rounding numbers.

Finally, I practiced incrementing variables and formatting strings to include multiple variables, enhancing my understanding of Python's data handling and string formatting capabilities.

#### [B. Data Types](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-002/Exercises/1-data-types.py)

In this exercise, I worked on manipulating and calculating with string and integer data types in Python. The challenge was to take a two-digit number as a string input, extract each digit, convert them into integers, and then sum them.

After capturing the two-digit number as a string input, I extracted the first and second digits using indexing. Then, I converted these string digits into integers using the `int()` function. Finally, I added these two integer values together and printed the result.

This exercise taught me about string indexing, type conversion from strings to integers, and basic arithmetic operations in Python. It was a practical application of combining several fundamental programming concepts.

#### [C. BMI Calculator](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-002/Exercises/2-bmi-calculator.py)

In this exercise, I developed a basic BMI (Body Mass Index) calculator in Python. The program begins by asking the user to input their height in meters and weight in kilograms.

To calculate the BMI, I first converted the height and weight inputs from strings to floats using the `float()` function. Then, I applied the BMI formula, which is weight divided by height squared. Finally, I converted the resulting BMI value to an integer using the `int()` function for a cleaner output and printed the result.

This task was a practical application of input handling, type conversion, arithmetic operations, and output formatting in Python. It demonstrated how to build a simple yet functional tool using basic programming concepts.

#### [D. Life in Weeks](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-002/Exercises/3-life-in-weeks.py)

In this exercise, I created a program to calculate the time a person has left in days, weeks, and months, assuming they live up to 90 years old. The user inputs their current age, and the program computes the remaining time.

First, I converted the user's age from a string to an integer. Then, I calculated the years remaining by subtracting the user's age from 90. Using this value, I determined the months, weeks, and days left by multiplying the years remaining with the number of months, weeks, and days in a year, respectively.

The final output was formatted using a Python f-string to neatly display the calculated days, weeks, and months remaining. This exercise taught me about basic arithmetic operations, type conversion, and string formatting in Python, along with providing a practical application of these skills.

## Day 3

### Projects (Day 3)

#### [3. Treasure Island - Choose Your Adventure CLI Game](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-003/Projects/treasure-island.py)

### Exercises (Day 3)

#### [A. Control Flow](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-003/Exercises/0-control-flow.py)

In this exercise, I learned about implementing control flow in Python using conditional statements. The program simulates a rollercoaster ticketing system that determines eligibility and ticket pricing based on the user's height and age.

The program starts by welcoming the user and asking for their height in centimeters. It then initializes a variable `bill` to 0, which will later be used to calculate the total ticket cost.

The first `if` statement checks if the user is tall enough to ride the rollercoaster (height >= 120 cm). If so, it proceeds to ask for the user's age to determine the ticket price:
- If the user is under 12 years old, they are charged $5.
- If the user is between 12 and 18 years old, they are charged $7.
- If the user is between 45 and 55 years old, they ride for free.
- All other ages are considered adults and are charged $12.

Next, the program asks if the user wants a photo taken. If the answer is "Y" for yes, an additional $3 is added to the bill.

Finally, the total bill is calculated and displayed. If the user is not tall enough to ride, the program prints a message indicating they cannot ride the rollercoaster.

#### [B. Odd or Even](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-003/Exercises/1-odd-or-even.py)

In this exercise, I focused on creating a simple program in Python to determine if a number is odd or even. The program begins by prompting the user to input a number, which is then converted to an integer using the `int()` function.

The core of this program lies in the use of the modulus operator (`%`) to check if the number is odd or even. The modulus operator returns the remainder of a division operation. In this case, it checks the remainder of the number divided by 2.

The `if` statement checks if the remainder of the number divided by 2 is equal to 1 (`number % 2 == 1`):
- If true, it means the number is odd, and the program prints "This is an odd number."
- If false (i.e., the remainder is 0), it means the number is even, and the program prints "This is an even number."

This exercise was a straightforward yet effective demonstration of using the modulus operator to perform a common mathematical check in programming and covered essential concepts like input handling, type conversion, conditional statements, and basic arithmetic operations in Python. 

#### [C. BMI Calculator V2 Upgrade](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-003/Exercises/2-bmi-calculator-v2.py)

In this exercise, I progressed to an advanced version of the BMI (Body Mass Index) Calculator (version 2), enhancing the functionality to provide more detailed feedback based on the BMI value. Compared to version 1, this version includes conditional statements to categorize the BMI result into different health categories.

Key changes and learnings in this version include:

1. **Immediate Type Conversion of Inputs**: Unlike version 1 where the height and weight inputs were initially taken as strings and then converted to floats, version 2 directly converts the user inputs to floats. This streamlines the code.

2. **Rounded BMI Calculation**: The BMI is calculated using the same formula as in version 1 (weight divided by height squared). However, in version 2, the `round()` function is used to round the BMI to the nearest whole number, providing a more user-friendly output.

3. **Conditional Statements for Health Categories**: The program uses a series of `if-elif-else` statements to categorize the BMI value:
    - A BMI less than 18.5 is categorized as underweight.
    - A BMI from 18.5 to less than 25 is considered normal weight.
    - A BMI from 25 to less than 30 is categorized as slightly overweight.
    - A BMI from 30 to less than 35 is considered obese.
    - A BMI of 35 or more is categorized as clinically obese.

    Each category triggers a specific print statement, providing the user with both their BMI value and the corresponding health category.

#### [D. Leap Year](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-003/Exercises/3-leap-year.py)

In this exercise, I developed a program in Python to determine whether a given year is a leap year. The program employs nested conditional statements to apply the rules that define a leap year.

The process begins with prompting the user to input a year, which is then converted into an integer using the `int()` function.

The rules for determining a leap year are as follows:
1. **Divisible by 4**: The year must be evenly divisible by 4.
2. **Century Years**: If the year is a century (divisible by 100), it must also be divisible by 400 to be a leap year.

The program's logic is structured as:
- First, it checks if the year is divisible by 4. If not, it's not a leap year.
- If the year is divisible by 4, it then checks if it's a century year (divisible by 100). 
  - If it is a century year, it must also pass the check of being divisible by 400 to be considered a leap year.
  - If it's not a century year, it is a leap year.

This arrangement of `if-else` statements within each other, known as nested conditional statements, effectively applies these rules. Based on these checks, the program prints either "Leap year." or "Not leap year." accordingly.

This exercise was an excellent demonstration of how nested conditional statements can be used to solve problems that require multiple layers of decision-making. It covered concepts like input handling, arithmetic operations with the modulus operator, and complex conditional logic in Python.

#### [E. Pizza Order](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-003/Exercises/4-pizza-order.py)

In this exercise, I created a simple pizza order calculator in Python to demonstrate conditional logic and basic arithmetic operations. The program simulates a pizza ordering process, calculating the total cost based on the customer's choices.

The program begins by welcoming the user to "Python Pizza Deliveries" and prompts them to choose the size of the pizza (Small, Medium, or Large), whether they want pepperoni, and if they desire extra cheese.

The logic of the program is structured as follows:
1. **Base Price for Pizza Size**: The program first checks the size of the pizza. Depending on whether it's Small (S), Medium (M), or Large (L), a base price is set (15, 20, or 25 dollars respectively).
2. **Adding Cost for Pepperoni**: If the user opts for pepperoni, an additional cost is added. This cost varies based on the size of the pizza (2 dollars for Small, 3 dollars for Medium and Large).
3. **Extra Cheese Addition**: Independently of the size and pepperoni choice, if the user wants extra cheese, an additional 1 dollar is added to the total price.

After considering all these choices, the final bill is calculated and printed to the user.

This exercise was a practical application of using `if-elif-else` statements to handle multiple conditions and update a variable based on these conditions. It also demonstrated string comparison in conditional statements and basic arithmetic operations for calculating the total price.

#### [F. Love Calculator](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-003/Exercises/5-love-calculator.py)

In this exercise, I created a playful "Love Calculator" program in Python, which combines string manipulation, arithmetic operations, and conditional logic. The program calculates a "love score" based on the names of two individuals.

The program starts by welcoming the user to the Love Calculator and prompts them to input two names. The logic of the program is as follows:

1. **Combine and Lowercase Names**: The entered names are concatenated and converted to lowercase. This is to ensure that the counting of letters is not case-sensitive.

2. **Counting Specific Letters for 'TRUE' and 'LOVE'**:
   - It counts the occurrences of each letter in 'TRUE' (t, r, u, e) within the combined string.
   - Similarly, it counts the occurrences of each letter in 'LOVE' (l, o, v, e) within the combined string.
   - The counts for each set of letters are then summed to form two numbers.

3. **Calculating the Love Score**: The love score is formed by concatenating the sums of 'TRUE' and 'LOVE' counts and converting this string back to an integer.

4. **Conditional Statements for Output**:
   - If the love score is less than 10 or greater than 90, a humorous message is printed, indicating a volatile combination.
   - If the love score is between 40 and 50, it prints a message suggesting moderate compatibility.
   - For all other scores, the love score is simply printed.

This exercise was a fun and creative way to apply various Python programming concepts & excellent for understanding basic programming concepts in a light-hearted context. It involved string concatenation, the use of the `count()` method for strings, arithmetic operations, type conversions, and implementing conditional logic based on calculated values.

## Day 4

### Projects (Day 4)

#### [4. Rock Paper Scissors - CLI Game](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-004/Projects/4-rock-paper-scissors.py)

### Exercises (Day 4)

#### [A. Random Module](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-004/Exercises/0-random-module.py)

In this exercise, I explored various aspects of Python programming, including the use of the `random` module, list manipulation, and commenting out code. The program is a collection of small snippets demonstrating different concepts.

1. **Using the `random` Module**:
   - The program starts by importing the `random` module, which provides functions for generating random numbers.
   - `random.randint(1, 10)` generates a random integer between 1 and 10.
   - `random.random() * 5` generates a random floating-point number between 0 and 5.

2. **Generating a Random Love Score**:
   - The program uses `random.randint(1, 100)` to simulate a random love score between 1 and 100, showcasing a practical application of generating random numbers. This is just as scientific as the first method used (neither is scientific in any way).

3. **List Manipulation and Access**:
   - A list named `states_of_america` is created, containing names of U.S. states.
   - The program demonstrates accessing the first and last elements of the list using index `0` and `-1` respectively.
   - Although there are commented lines for modifying the list (like changing an element and extending the list), they are not executed in the current version.

4. **Nested Lists and List Concatenation**:
   - The `dirty_dozen` list is created by concatenating two lists, `fruits` and `vegetables`, into a nested list. This illustrates how lists can store other lists, allowing for complex data structures.

5. **Commenting Out Code**:
   - Several lines in the script are commented out (e.g., `import my_module`, modifications to `states_of_america`, and the original `dirty_dozen` list). This demonstrates how to temporarily disable code in Python without deleting it, useful for testing and debugging.

This exercise provided a broad overview of different Python features, from random number generation and list manipulation to commenting and basic data structures.

#### [B. Heads or Tails](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-004/Exercises/1-heads-or-tails.py)

In this exercise, I created a simple "Heads or Tails" program using Python's `random` module. This exercise demonstrates the use of random number generation and basic conditional logic.

The program works as follows:

1. **Import the Random Module**: The first step is importing the `random` module, which provides functions for generating random numbers.

2. **Generate a Random Integer**: The program uses `random.randint(0, 1)` to generate a random integer that's either 0 or 1. This simulates the two possible outcomes of a coin flip.

3. **Conditional Logic to Determine the Outcome**:
   - An `if` statement checks the value of `face_value`. If it equals 0, the program prints "Tails". Otherwise, it prints "Heads".
   - This binary choice effectively simulates the flipping of a coin.

#### [C. Banker Roulette](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-004/Exercises/2-banker-roulette.py)

In the "Banker Roulette" exercise, I implemented a program in Python that randomly selects a person from a list to "buy the meal today." This exercise demonstrates string manipulation, list handling, and the use of the `random` module for generating random numbers.

The program's workflow is as follows:

1. **Input and String Splitting**:
   - The program starts by asking the user to input a string of names separated by commas.
   - It then uses the `split(", ")` method on the input string to create a list of names. This method splits the string at every comma followed by a space, effectively turning a single string into a list of individual names.

2. **Importing and Using the Random Module**:
   - The `random` module is imported at the beginning of the program.
   - To select a random name, the program first calculates the length of the names list and adjusts it to align with Python's zero-based indexing (hence `len(names) - 1`).

3. **Random Selection**:
   - `random.randint(0, name_len)` is used to generate a random index between 0 and the last index of the names list.
   - The program then uses this index to select a random name from the list.

4. **Output**:
   - Finally, the program prints out a message stating which name (person) is selected to buy the meal.

#### [D. Treasure Map](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-004/Exercises/3-treasure-map.py)

In the "Treasure Map" exercise, I developed a program in Python that simulates placing a treasure mark on a simple grid map. This exercise is a great example of using lists, indexing, and conditional logic in Python.

1. **Creating the Map**:
   - The map is represented by a list of lists (`map`), where each sublist (`row1`, `row2`, `row3`) represents a row in the map.
   - Each row contains square symbols (`"⬜️"`) to represent empty spaces.

2. **Displaying the Initial Map**:
   - The initial state of the map is printed using formatted strings, showing the three rows of the map.

3. **User Input for Treasure Location**:
   - The program asks the user to input the position for placing the treasure. This position input is expected to be a two-digit number where the first digit represents the column and the second digit represents the row.

4. **Parsing the Input**:
   - The input string is processed to determine the specific row and column. The first digit (column) is adjusted by subtracting 1 to align with Python's zero-based indexing.
   - The second digit is used directly to identify the row as the input is in a user-friendly format (starting from 1).

5. **Updating the Map**:
   - Conditional statements (`if-elif-else`) determine which row to update based on the user's input.
   - The appropriate row is then updated by replacing the corresponding square symbol with an "X" to mark the treasure's location.

6. **Printing the Updated Map**:
   - Finally, the updated map is printed, showing the new position of the treasure.

This exercise effectively demonstrates how to manipulate lists and use indexing in Python. It also provides a clear example of how user input can be taken and processed to interact with data structures, in this case, updating a list based on the input.

## Day 5

### Projects (Day 5)

#### [5. Password Generator](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-005/Projects/5-password-generator.py)

### Exercises (Day 5)

#### [A. Basic Loops](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-005/Exercises/0-basic-loops.py)

In this exercise, I explored the use of basic loops in Python, focusing on the `for` loop with two distinct examples.

The first part of the exercise involved iterating over a list of fruits. I defined a list named `fruits` containing "Apple", "Peach", and "Pear". Using a `for` loop, I iterated through each item in the list. For each fruit, the loop printed the fruit's name and then the fruit's name followed by " Pie". This demonstrated how to access and manipulate list elements within a loop, a fundamental skill in Python for working with collections of data.

The second part of the exercise demonstrated the use of the `range` function with a `for` loop. I initialized a variable `total_number` to 0 and used a `for` loop to iterate over a range of numbers from 1 to 100. In each iteration, the loop added the current number to `total_number`. This section illustrated how `range` can be used for numeric iteration and how to accumulate a sum within a loop. The final print statement displayed the total sum of numbers from 1 to 100.

Overall, these examples served as an introduction to `for` loops in Python. They showed how loops can be used for iterating over lists and performing repeated calculations. Such techniques are essential in Python for automating tasks, processing data, and carrying out calculations over sequences.

#### [B. Average Height](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-005/Exercises/1-average-height.py)

In this exercise, I created a program to calculate the average height from a list of student heights in Python, demonstrating basic data collection, type conversion, and arithmetic operations.

The program begins by prompting the user to input a list of student heights, which are entered as a space-separated string. This string is then split into a list of individual height strings using `.split()`. The `for` loop that follows converts each string in the list to an integer, updating the `student_heights` list with these integer values. This conversion is crucial for the arithmetic operations that follow.

The next part of the code involves calculating the total height and counting the number of students. Two separate `for` loops are used for this purpose. The first loop iterates over each height in the `student_heights` list, adding the heights to the `total_height` variable. The second loop counts the number of students by incrementing `student_count` for each element in the `student_heights` list.

Finally, the average height is calculated by dividing the `total_height` by `student_count` and rounding the result to the nearest whole number. This average is then printed out. This exercise effectively demonstrates handling user input, iterating over lists, basic arithmetic operations, and type conversion in Python. It's a practical example of how Python can be used to process and analyze data inputs.

#### [C. High Score](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-005/Exercises/2-high-score.py)

In this Python exercise, I developed a program to find the highest score in a list of student scores. The exercise emphasized the use of loops, conditional statements, and handling user input.

The program starts by requesting the user to input a list of student scores as a space-separated string. This string is then split into a list of individual score strings using the `.split()` method. A `for` loop is then employed to iterate through this list, converting each string score to an integer. This conversion is essential for the comparison operations that follow.

Once the scores are converted into integers, the code aims to identify the highest score. To achieve this, a variable `high_score` is initialized to 0. The program then iterates over each score in the `student_scores` list using a `for` loop. Within this loop, a conditional statement checks if the current score is greater than the value stored in `high_score`. If it is, `high_score` is updated with this new value. This loop-and-check mechanism ensures that at the end of the iteration, `high_score` holds the maximum score from the list.

The final step is to print the highest score. The program outputs this information in a formatted string, clearly indicating the highest score found in the class.

#### [D. Adding Even Numbers](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-005/Exercises/3-adding-even-nums.py)

In this exercise, I implemented a Python program to calculate the sum of all even numbers from 1 to 100, demonstrating the use of loops, conditional statements, and arithmetic operations.

The program defines a variable `total_number` initialized to 0. This variable is used to accumulate the sum of even numbers. A `for` loop is then used to iterate over a range of numbers from 1 to 100. The `range(1, 101)` function generates a sequence of numbers starting from 1 and ending at 100.

Within the loop, a conditional statement checks whether each number is even. This is done using the modulus operator (`%`), which returns the remainder of a division. If a number divided by 2 has a remainder of 0 (`number % 2 == 0`), it is an even number. When an even number is identified, it is added to `total_number`.

After the loop completes, the program prints `total_number`, which by then contains the sum of all even numbers from 1 to 100.

#### [E. FizzBuzz](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-005/Exercises/4-fizz-buzz.py)

In this exercise, I implemented the classic "FizzBuzz" program in Python, a common test used in programming interviews. The task was to print each number from 1 to 100, but for multiples of three, print "Fizz" instead of the number, and for the multiples of five, print "Buzz". For numbers which are multiples of both three and five, print "FizzBuzz". This exercise highlighted the use of loops, conditional statements, and modulo operations.

The program utilizes a `for` loop to iterate over a range of numbers from 1 to 100. For each number in this range, a series of conditional checks are performed:

1. The first `if` statement checks if the number is divisible by both 3 and 5 (`num % 3 == 0 and num % 5 == 0`). If true, "FizzBuzz" is printed. This check is important to perform first to ensure that numbers like 15, which are divisible by both, are correctly identified as "FizzBuzz" rather than just "Fizz" or "Buzz".

2. The `elif` (else if) statement then checks if the number is divisible by 3 (`num % 3 == 0`). If true, it prints "Fizz".

3. Another `elif` statement checks if the number is divisible by 5 (`num % 5 == 0`). If true, it prints "Buzz".

4. Finally, the `else` statement covers all other cases where the number is neither divisible by 3 nor 5. In these cases, the number itself is printed.

This exercise demonstrates the practical application of loops for iterating over a range, the use of modulo operator to check divisibility, and the implementation of conditional logic to determine what to print based on these divisibility checks.

## Day 6

### Projects (Day 6)

#### [6. Reeborg Maze](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-006/Projects/5-reeborg-maze.py)

### Exercises (Day 6)

#### [A. Functions](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-006/Exercises/0-functions.py)

#### [B. Reeborg Square](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-006/Exercises/1-reeborg-square.py)

#### [C. Reeborg Hurdles](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-006/Exercises/2-reeborg-hurdles.py)

#### [D. Reeborg Variable Width Hurdles](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-006/Exercises/3-reeborg-width-hurdles.py)

#### [E. Reeborg Variable Height Hurdles](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-006/Exercises/4-reeborg-height-hurdles.py)

## Day 7

### Projects (Day 7)

#### [7. Parachute Man - CLI Game](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-007/Projects/4-parachute-man.py)

### Exercises (Day 7)

#### [A. Building Parachute Man - Part 1](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-007/Exercises/1-parachute-man.py)

#### [B. Building Parachute Man - Part 2](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-007/Exercises/2-parachute-man.py)

#### [C. Building Parachute Man - Part 3](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-007/Exercises/3-parachute-man.py)

## Day 8

### Projects (Day 8)

#### [8. Caesar Cipher](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-008/Projects/7-caesar-cipher.py)

### Exercises (Day 8)

#### [A. Greet Function](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-008/Exercises/1-greet-function.py)

In this exercise, I developed a Python program that demonstrates the use of functions, specifically focusing on creating a custom function for greeting a user. The task involved obtaining user input for a name and location, and then using these inputs in a personalized greeting.

The program starts by asking the user two questions: the name of the person they are greeting and where that person lives. These inputs are captured using the `input()` function and stored in the variables `name` and `location`, respectively.

Following this, a function named `greet` is defined. This function takes two parameters: `name` and `location`. Inside the function, three print statements are used to generate a personalized greeting. The first print statement says hello to the person, the second asks about the location they are in, and the third makes a remark about the day being lovely, addressing the person by name again. This use of parameters within the function allows for dynamic and reusable code.

Finally, the `greet` function is called with `name` and `location` as arguments. This call executes the function with the specific inputs provided by the user, displaying the customized greeting messages.

#### [B. Paint Area Calculator](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-008/Exercises/2-paint-area-calculator.py)

In this exercise, I created a Python program to calculate the number of cans of paint needed to paint a wall, showcasing the use of functions, arithmetic operations, and external libraries.

The program begins by importing the `math` module, which provides access to various mathematical functions. One of these functions, `math.ceil()`, is used later in the code to round up to the nearest whole number.

The core functionality of the program is encapsulated within the `paint_calc` function. This function takes three parameters: `height`, `width`, and `cover`. The `height` and `width` parameters represent the dimensions of the wall to be painted, while `cover` represents the coverage of a single can of paint (in square units).

Inside the function, the total number of cans needed is calculated by dividing the area of the wall (`height * width`) by the coverage per can (`cover`). Since it's not practical to buy a fraction of a can, the result is rounded up to the nearest whole number using `math.ceil()`. This ensures that there is enough paint to cover the entire wall. The function then prints out the number of cans needed.

To use this function, the program prompts the user to input the height and width of the wall. These inputs are captured using `input()` and converted to integers. The variable `coverage` is set to 5, representing the area that a single can of paint can cover.

Finally, the `paint_calc` function is called with the user-provided height and width, along with the predefined coverage. The function calculates and displays the number of paint cans required.

#### [C. Prime Number Check](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-008/Exercises/3-prime-number-check.py)

In this exercise, I developed a Python program to check whether a given number is a prime number, demonstrating the use of functions, loops, and conditional statements.

The program defines a function named `prime_checker` which takes one parameter: `number`. This function is responsible for determining whether the provided number is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.

The function first checks if the number is greater than 1, as prime numbers are by definition greater than 1. If the number is not greater than 1, it immediately prints that it's not a prime number.

For numbers greater than 1, the function uses a `for` loop to check for factors other than 1 and the number itself. It iterates through numbers starting from 2 up to, but not including, the number in question. For each number `i` in this range, the function checks if the `number` is divisible by `i` (`number % i == 0`). If any such division is found (indicating the number is divisible by a number other than 1 and itself), the function prints that it's not a prime number and exits the loop using `break`.

If the loop completes without finding any factors, the `else` block corresponding to the `for` loop is executed, indicating that no divisors were found and the number is a prime. The function then prints that it's a prime number.

To use this function, the program prompts the user to input a number. This input is captured using `input()`, converted to an integer, and stored in variable `n`. The `prime_checker` function is then called with `n` as its argument.

This exercise is a good example of how Python can be used to solve mathematical problems and demonstrates the practical application of functions, loops, and conditional logic in programming.

#### [D. Building Caesar Cipher - Part 1](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-008/Exercises/4-caesar-cipher1.py)

In the first part of building a Caesar Cipher in Python, I focused on creating a basic encryption function. The program starts with a list called `alphabet`, which contains all the lowercase letters of the alphabet, repeated twice to facilitate letter shifting for encryption.

The user is prompted to input a message and the number of positions to shift each letter in the message (the shift value). The `encrypt` function is then defined to perform the encryption. It takes the text and the shift value as arguments. Inside the function, for each letter in the input text, its position in the `alphabet` list is found. This position is then shifted by the specified shift amount to find the new letter. The new letter is added to a string `cipher_text`, which accumulates the encrypted message. After processing all letters, the encrypted message is printed.

This part of the exercise demonstrates the basics of string manipulation, use of lists, and iteration with `for` loops in Python, forming the foundation for a simple Caesar Cipher encryption tool.

#### [E. Building Caesar Cipher - Part 2](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-008/Exercises/5-caesar-cipher2.py)

In the second part of the Caesar Cipher exercise, I expanded the functionality to include decryption. The initial setup remains the same with an `alphabet` list and user input for text, direction (encode or decode), and shift amount.

Two functions are defined in this part: `encrypt` (similar to Part 1) and `decrypt`. The `decrypt` function reverses the encryption process. It takes the encrypted text and the shift value, then for each letter in the encrypted text, finds its position in the `alphabet` list. It then shifts the position backwards by the shift amount to retrieve the original letter and constructs the decrypted message.

The program checks the user input for direction and calls the appropriate function (either `encrypt` or `decrypt`). This part of the exercise illustrates how to add more functionality to a program, specifically how to reverse an algorithm's effect, a common requirement in encryption and decryption scenarios.

#### [F. Building Caesar Cipher - Part 3](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-008/Exercises/6-caesar-cipher3.py)

In the final part of the Caesar Cipher exercise, the code is optimized by combining the encryption and decryption functionalities into a single function called `caesar`. The program still starts with the `alphabet` list and takes user inputs for the direction of the operation (encode or decode), the message, and the shift value.

The `caesar` function is designed to handle both encryption and decryption based on the direction specified. It uses modular arithmetic (`% 52`, where 52 is twice the length of the alphabet list) to ensure the new position of each letter wraps around the alphabet list correctly. This is crucial as it deals with the issue of the shift operation moving beyond the end of the list.

For encoding, each letter's position is found and shifted forward; for decoding, the process is reversed by shifting backward. The resulting letters are concatenated to form the encoded or decoded message, which is then printed.

This part of the exercise demonstrates the use of modular arithmetic in programming to create more robust and error-resistant applications. It shows the importance of optimizing code by combining similar functionalities and the practical use of functions to simplify complex tasks.

## Day 9

### Projects (Day 9)

#### [9. Blind Auction](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-009/Projects/5-blind-auction.py)

### Exercises (Day 9)

#### [A. Dictionary](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-009/Exercises/1-dictionary.py)

In this exercise, I demonstrated the use of dictionaries in Python, a powerful data structure for storing key-value pairs. The exercise covered creating a dictionary, adding to it, accessing its elements, and iterating through it.

I created a `programming_dictionary` with initial entries for "Bug" and "Function," each paired with their definitions. I accessed and printed individual definitions using their keys and also displayed the entire dictionary to show its contents.

Next, I expanded the dictionary by adding a new entry for "Loop" and its definition. This step highlighted how to dynamically add new key-value pairs to a dictionary.

Finally, I used a `for` loop to iterate over each key in the dictionary, printing both the key and its associated value. This part of the exercise showcased how to efficiently traverse a dictionary and access its contents.

#### [B. Grading Program](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-009/Exercises/2-grading-program.py)

In this exercise, I implemented a grading program in Python using dictionaries. The program assigned grades to students based on their scores, demonstrating the use of conditional statements and iterating through dictionary items.

I started with a `student_scores` dictionary containing names of students as keys and their scores as values. Then, I created an empty dictionary `student_grades` to store the grades for each student.

Using a `for` loop, I iterated over each key (student's name) in `student_scores`. Within the loop, I used a series of `if-elif` statements to assign grades based on each student's score. The grading criteria were as follows: scores 91 and above were graded as "Outstanding", scores between 81 and 90 as "Exceeds Expectations", scores between 71 and 80 as "Acceptable", and scores 70 or below as "Fail".

After determining the appropriate grade for each student, I added a new key-value pair to `student_grades`, with the student's name as the key and their assigned grade as the value.

Finally, I printed the `student_grades` dictionary to display the assigned grades for each student.

#### [C. Nesting Dictionaries](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-009/Exercises/3-nesting-dictionaries.py)

In this exercise, I worked with nesting dictionaries in Python, a useful technique for creating structured and hierarchical data models. The exercise involved two different approaches to structuring a travel log.

1. **Dictionary of Dictionaries:**

   The first `travel_log` is a dictionary where each key is a country name, and the value is another dictionary containing details about travels to that country. For instance, the key "France" maps to a dictionary with keys "cities_visited" (a list of cities) and "total_visits" (an integer indicating the total number of visits).

   This structure is useful when you need to access information about travels to a specific country quickly. You can directly access the details by using the country name as a key.

2. **List of Dictionaries:**

   The second `travel_log` is a list, with each element being a dictionary that contains information about travels to a particular country. Each dictionary includes keys like "country", "cities_visited", and "total_visits".

   This structure is more suitable when you need to iterate over all travel records, as it stores each record as a separate dictionary within a list. This makes it easy to loop through all travel entries.

Both methods showcase different ways of using nested structures in Python. The first method is efficient for direct access using a key, while the second is better for sequential processing of all records.

#### [D. Travel Log](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-009/Exercises/4-travel-log.py)

In this exercise, I worked on expanding a Python program that maintains a travel log using a list of dictionaries. The program demonstrates the use of functions for data manipulation within complex data structures.

I started with a `travel_log` list containing dictionaries, where each dictionary represents a record of visits to a country. Each dictionary has three keys: "country" (the name of the country visited), "visits" (the number of visits to that country), and "cities" (a list of cities visited in that country).

The core functionality of this exercise was the addition of a new function, `add_new_country`, which allows for the addition of new travel records to the `travel_log`. The function takes three parameters: `country_visited` (the name of the country visited), `times_visited` (the number of times visited), and `cities_visited` (a list of cities visited in that country).

Inside the function, a new dictionary `new_country` is created and populated with the provided information. This new dictionary is then appended to the `travel_log` list, effectively updating the travel log with the new travel record.

After defining the function, I tested it by adding a new record for "Russia" with 2 visits and cities ["Moscow", "Saint Petersburg"]. Finally, I printed the updated `travel_log` to verify the addition.

This exercise demonstrates how functions can be used to manage and update complex data structures like lists of dictionaries in Python. It's a practical example of how Python can be used to organize and modify data in a structured and readable format.

## Day 10

### Projects (Day 10)

#### [10. CLI Calculator with Multiple Functions](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-010/Projects/5-calculator.py)

### Exercises (Day 10)

#### [A. Functions with Outputs](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-010/Exercises/1-functions-with-outputs.py)

This exercise explores functions with outputs, focusing on how to define functions, return values, and utilize those returned values.

1. **Simple Multiplication Function:**
   - **Function:** `my_function`
   - **Purpose:** This function performs a simple calculation (3 multiplied by 2) and returns the result.
   - **Return Value:** The function returns the calculated value (6) but does not print it. The result is computed and returned but not used, as there's no print statement or variable assignment to capture the output when `my_function()` is called.

2. **Name Formatting Function:**
   - **Function:** `format_name`
   - **Parameters:** Two parameters, `f_name` for the first name and `l_name` for the last name.
   - **Process:**
     - It formats both the first and last names to title case (first letter capitalized and the rest in lowercase) using the `title()` string method.
     - The formatted names are then concatenated with a space in between.
   - **Return Value:** Returns the formatted full name as a string.
   - **Usage Examples:**
     - `formatted_string = format_name("JoRdAn", "MULLER")` assigns the formatted name "Jordan Muller" to `formatted_string` and then prints it.
     - `print(format_name("JoRdAn", "MULLER"))` directly prints the formatted name "Jordan Muller".

This lesson demonstrates the creation and use of functions with return values, emphasizing on returning processed data and then using it, either by printing it directly or by storing it in a variable for further use. It shows the versatility of functions in handling data and the convenience of separating logic (function definition) from execution (calling the function).

#### [B. Multiple Return Values](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-010/Exercises/2-multiple-return-values.py)

In this exercise, the `format_name` function is enhanced to handle multiple return scenarios, illustrating how Python functions can return different types of values based on conditional logic.

**Function:** `format_name`
- **Parameters:** Two parameters - `f_name` for the first name and `l_name` for the last name.
- **Process:**
  - The function begins by checking if either `f_name` or `l_name` is an empty string. This is done using an `if` statement that checks for empty input.
  - **Empty Name Check:** If either the first name or last name is empty, the function immediately returns a message: `"Empty Name, Please Provide a Valid Name"`. This safeguard ensures that the function processes only valid names.
  - **Name Formatting:** If both names are provided, it formats them to title case (first letter capitalized, the rest in lowercase) using the `title()` string method.
- **Return Value:** Depending on the input, the function either returns a warning message for empty names or a formatted full name as a string.

**Usage:**
- The function is called within a `print` statement. It takes user input directly through the `input()` function for both first and last names.
- Depending on the user input, it either displays a formatted name or a message indicating that a valid name wasn't provided.

#### [C. Days in Month](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-010/Exercises/3-days-in-month.py)

This Python exercise consists of two functions: one to determine if a year is a leap year (`is_leap`), and another to find out the number of days in a given month of a specific year (`days_in_month`).

- The user is prompted to enter a year and a month.
- The `days_in_month` function is then called with these inputs to determine and print the number of days in that month of the specified year.

1. **Leap Year Function: `is_leap(year)`**
   - **Purpose:** Determines whether a given year is a leap year.
   - **Logic:**
     - A year is a leap year if it is divisible by 4.
     - However, if the year is also divisible by 100, it must also be divisible by 400 to be a leap year.
   - **Return Value:** Returns `True` if the year is a leap year, and `False` otherwise.

2. **Days in Month Function: `days_in_month(year, month)`**
   - **Purpose:** Calculates the number of days in a specific month of a given year.
   - **Parameters:** Two parameters - `year` and `month`.
   - **Process:**
     - The function uses a list `month_days` to store the number of days in each month, assuming a non-leap year.
     - It then checks if the year is a leap year and if the month is February (month 2). If both conditions are met, it returns 29 (for February in a leap year).
     - Otherwise, it returns the number of days from the `month_days` list corresponding to the given month.
   - **Return Value:** Number of days in the specified month of the given year.

#### [D. Docstrings](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-010/Exercises/4-docstrings.py)

In this exercise, I learned about creating a function with **docstrings** and implementing conditional logic in Python. The task was to define a function named `format_name` that formats a first and last name into title case.

The function `format_name` takes two parameters, `f_name` and `l_name`, representing the first and last names, respectively. I included a docstring at the beginning of the function definition, which serves as documentation. This docstring explains the purpose of the function: "Take a first and last name and format it to return the title case version of the name."

Inside the function, I added a conditional check to handle cases where either the first or last name is an empty string. If either `f_name` or `l_name` is empty, the function returns a message prompting for a valid name. Otherwise, the function proceeds to format both names to title case using the `.title()` method. This method capitalizes the first letter of each word while making all other letters lowercase. Finally, the function returns the formatted names concatenated with a space in between.

To test the function, I used the `input()` function to capture the user's first and last names. Then, I passed these inputs to the `format_name` function and printed the result.

## Day 11

### Projects (Day 11)

#### [11. Blackjack - CLI Game](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-011/Projects/1-blackjack.py)

## Day 12

### Projects (Day 12)

#### [12. Number Guessing - CLI Game](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-012/Projects/2-guess-num-game.py)

### Exercises (Day 12)

#### [A. Namespaces](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-012/Exercises/1-namespaces.py)

In this exercise, I explored the concept of namespaces and scope in Python, focusing on the differences between local, global, and block scopes.

1. **Modifying Global Scope**:
    - Initially, the global variable `enemies` is commented out. Uncommenting and modifying this variable within a function without declaring it as global would have created a local variable inside the function, not affecting the global `enemies`.
    - By using the `global` keyword inside `increase_enemies()`, it's possible to modify the global `enemies` variable.
    - The exercise demonstrates that without the `global` keyword, a new local variable is created inside the function, which doesn't affect the global variable with the same name.

2. **Global Constants**:
    - Constants like `PI`, `URL`, and `USER_NAME` are defined at the top level of the script, making them globally accessible. These are typically written in uppercase to distinguish them as constants that shouldn't be changed.

3. **Local Scope**:
    - In the `drink_potion()` function, `potion_strength` is a local variable. It's only accessible within the function itself.
    - Attempting to print `potion_strength` outside the function results in an error since it's not defined in the global scope.

4. **Nested Functions and Global Scope**:
    - In the `game()` function, there's a nested `drink_potion()` function. This nested function can access variables in the global scope (like `player_health`), but it has its own local scope for variables declared within it.

5. **No Block Scope in Python**:
    - Python does not have block scope (unlike languages like JavaScript). Variables declared inside a block (like an `if` statement) are accessible outside the block.

6. **Accessing Variables Outside Their Scope**:
    - The last part of the code attempts to print `new_enemy` outside the `create_enemy()` function. Since `new_enemy` is defined within the function, it's not accessible outside, demonstrating the concept of local scope.

This exercise was an insightful exploration of how Python handles variable scopes. It showed the importance of understanding scope rules to avoid unexpected behavior in programs, especially in functions and nested structures. It highlighted that variables have different accessibility depending on where they are defined and that the `global` keyword is necessary to modify global variables within a function.

## Day 13

### Exercises (Day 13)

#### [A. Beginner Debugging](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-013/Exercises/1-beginner-debugging.py)

In this exercise, I delved into the basics of debugging in Python. It covered various debugging techniques and concepts, highlighting common issues that beginners might encounter.

1. **Describe Problem**:
    - The function `my_function()` uses a `for` loop to iterate from 1 to 20. The intention is to print "You got it" when `i` equals 20. The loop correctly includes 20 in its range, ensuring the desired message is printed. No apparent issue is present in this snippet.

2. **Reproduce the Bug**:
    - The code snippet uses `randint` to simulate a dice roll. The `dice_imgs` list contains symbols for dice faces. Since lists are zero-indexed, `randint(0, 5)` correctly matches the indices of `dice_imgs`. The commented line `print(dice_imgs[6])` would cause an `IndexError` because the list has no element at index 6.

3. **Play Computer**:
    - The code asks for a year of birth and categorizes the user as a millennial or Gen Z based on the year. However, there's a logic error: years exactly equal to 1994 are not covered by any condition. Adjusting the conditions to include 1994 in one of the categories would resolve this oversight.

4. **Fix the Errors**:
    - This snippet asks for the user's age and prints a message if the age is over 18. The code correctly converts the input to an integer and compares it against 18. There are no errors in this code; it should work as intended.

5. **Print is Your Friend**:
    - The code calculates the total number of words based on the number of pages and words per page. The user inputs these values. This snippet correctly computes `total_words` by multiplying `pages` by `word_per_page`. Uncommenting the print statements for `pages` and `word_per_page` would be helpful for debugging if there were issues in the calculations.

6. **Use a Debugger**:
    - The `mutate` function takes a list, doubles each item, and appends it to a new list `b_list`. This function appears to work correctly as it iterates over each element, performs the operation, and prints the resulting list.

This exercise provided a general overview of common debugging strategies: understanding the problem, reproducing bugs, stepping through the code, fixing logical errors, using print statements for inspection, and the concept of using a debugger. Each snippet represented a typical debugging scenario, emphasizing the importance of careful code review and testing in programming.

#### [B. Debug Odd & Even Program](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-013/Exercises/2-debug-odd-even.py)

In this exercise, I examined and debugged a Python program designed to check if a given number is odd or even.

##### Original Code with Bug:
The original code snippet had a syntax error:

```python
number = int(input("Which number do you want to check?"))

if number % 2 = 0:
  print("This is an even number.")
else:
  print("This is an odd number.")
```

The issue here was with the `if` statement. The code used a single equals sign (`=`) instead of a double equals sign (`==`). In Python, `=` is used for assignment, while `==` is used for comparison.

##### Debugged Code:
I corrected the syntax error by replacing `=` with `==` in the `if` statement. The fixed code looks like this:

```python
number = int(input("Which number do you want to check?"))

if number % 2 == 0:
    print("This is an even number.")
else:
    print("This is an odd number.")
```

##### Explanation:
- The program starts by asking the user to input a number, which is then converted into an integer using `int()`.
- It then checks if the number is even by using the modulus operator `%`. This operator returns the remainder of the division of `number` by 2.
- If the remainder is 0 (`number % 2 == 0`), it means the number is even, and the program prints "This is an even number."
- If the remainder is not 0, the `else` clause executes, and the program prints "This is an odd number."

#### [C. Debug Leap Year Program](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-013/Exercises/3-debug-leap-year.py)

In this exercise, I identified and fixed a bug in a Python program designed to determine whether a given year is a leap year.

##### Original Code with Bug:
The original code snippet had a type-related error:

```python
year = input("Which year do you want to check?")

if year % 4 == 0:
    if year % 100 == 0:
        if year % 400 == 0:
            print("Leap year.")
        else:
            print("Not leap year.")
    else:
        print("Leap year.")
else:
    print("Not leap year.")
```

The issue here was that the `input()` function returns a string, but the program requires an integer to perform the modulus operation.

##### Debugged Code:
To fix the issue, I converted the input to an integer using `int()`:

```python
year = int(input("Which year do you want to check?"))

if year % 4 == 0:
    if year % 100 == 0:
        if year % 400 == 0:
            print("Leap year.")
        else:
            print("Not leap year.")
    else:
        print("Leap year.")
else:
    print("Not leap year.")
```

##### Explanation:
- The program begins by prompting the user to enter a year. The input is then converted to an integer.
- The first `if` statement checks if the year is divisible by 4 (`year % 4 == 0`). This is the first condition for a leap year.
- If the year is divisible by 4, the program then checks if it is also divisible by 100. If it is (`year % 100 == 0`), the program further checks for divisibility by 400.
- For a year to be a leap year, if it is divisible by 100, it must also be divisible by 400 (`year % 400 == 0`). If it is, the program prints "Leap year." Otherwise, it prints "Not leap year."
- If the year is divisible by 4 but not by 100, it's also considered a leap year.

#### [D. Debug FizzBuzz Program](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-013/Exercises/4-debug-fizzbuzz.py)

In this exercise, I debugged a Python program designed to implement the FizzBuzz challenge, a common exercise used in programming interviews.

##### Original Code with Bug:
The original code snippet had logical errors related to conditional statements:

```python
for number in range(1, 101):
  if number % 3 == 0 or number % 5 == 0:
    print("FizzBuzz")
  if number % 3 == 0:
    print("Fizz")
  if number % 5 == 0:
    print("Buzz")
  else:
    print([number])
```

The issues were:
- The first `if` statement incorrectly used `or` instead of `and`, leading to "FizzBuzz" being printed for any number divisible by either 3 or 5, instead of both.
- The use of multiple `if` statements caused numbers divisible by 3, 5, or both to print multiple outputs (e.g., a number divisible by 3 would print both "FizzBuzz" and "Fizz").
- The `else` statement was aligned with the last `if`, causing numbers not divisible by 5 to print as a list `[number]` instead of just the number.

##### Debugged Code:
I corrected the logical errors by adjusting the conditional statements:

```python
for number in range(1, 101):
    if number % 3 == 0 and number % 5 == 0:
        print("FizzBuzz")
    elif number % 3 == 0:
        print("Fizz")
    elif number % 5 == 0:
        print("Buzz")
    else:
        print(number)
```

##### Explanation:
- The loop iterates through numbers from 1 to 100.
- The first `if` statement checks if a number is divisible by both 3 and 5 (`number % 3 == 0 and number % 5 == 0`). If true, it prints "FizzBuzz."
- The `elif` statements ensure that only one of the conditions is checked and executed. If the number is divisible by 3 but not 5, it prints "Fizz." If divisible by 5 but not 3, it prints "Buzz."
- If none of the above conditions are met, the `else` statement executes, printing the number.

## Day 14

### Projects (Day 14)

#### [1. Higher or Lower Game](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-014/Projects/1-higher-or-lower.py)

## Day 15

### Projects (Day 15)

#### [15. Coffee Machine Simulator - CLI Application](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-015/Projects/1-coffee-machine.py)

## Day 16

### Projects (Day 16)

#### [16. Coffee Machine Simulator v2 Upgrade - CLI Application](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-016/Projects)

### Exercises (Day 16)

#### [A. Object Oriented Programming](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-016/Exercises)

In this exercise, I analyzed two Python scripts that demonstrate basic concepts in Object-Oriented Programming (OOP) and module usage.

##### Script 1: Object-Oriented Concepts with Turtle Module

The first script, `1-object-oriented.py`, initially contains commented-out code that illustrates the use of the `turtle` module, a popular tool for basic graphics in Python. However, the active portion of the script focuses on using the `prettytable` module.

###### Commented-out Turtle Code:
- The script imports `Turtle` and `Screen` classes from the `turtle` module, along with another custom module `another_module`.
- It prints a variable from `another_module`.
- An instance of `Turtle` named `timmy` is created. This object is then used to draw on the screen, demonstrating basic features of the Turtle class like shape, color, and movement.
- A `Screen` object is created to control the window. The script prints the canvas height and width and uses `exitonclick()` to close the window when clicked.

###### Active PrettyTable Code:
- The script imports `PrettyTable` from `prettytable`.
- It creates an instance of `PrettyTable` named `table`.
- Two columns are added to the table with headers "Pokemon Name" and "Type", along with their respective values.
- The alignment of the table is set to left.
- Finally, the table is printed, showcasing a formatted table with the specified columns and rows.

##### Script 2: another_module.py

This script, named `another_module.py`, simply defines a variable:

```python
another_variable = 12
```

- This module is meant to be imported by other scripts. In the commented-out part of the first script, `another_module.another_variable` is printed, demonstrating how to access variables from imported modules.

##### Key Learnings:
- **Object-Oriented Programming**: The Turtle part of the script shows how to create and manipulate objects, a fundamental concept in OOP.
- **Module Usage**: Both parts of the script illustrate how to import and use modules and classes in Python.
- **PrettyTable Library**: The PrettyTable code demonstrates how third-party libraries can be used to enhance the functionality of Python scripts, in this case for data presentation.
- **Modular Programming**: By separating the variable into `another_module.py`, the script exemplifies the modular programming approach, promoting code reusability and organization.

## Day 17

### Projects (Day 17)

#### [17. Quiz/Trivia Application - CLI Game](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-017/Projects)

### Exercises (Day 17)

#### [A. Classes](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-017/Exercises/classes.py)

In this exercise, I explored the fundamental concepts of classes and objects in Python, specifically focusing on how to create and interact with class instances.

I started by defining a class named `User` using PascalCase, as is the convention for class names in Python. Inside the class, I defined an `__init__` method to initialize new `User` objects with attributes like `user_id`, `username`, `followers`, and `following`. The `followers` and `following` attributes were initialized to 0, assuming new users have no followers or are following anyone initially.

I also implemented a method called `follow`, which simulates one user following another. This method increases the `followers` count of the user being followed and the `following` count of the user who is following.

Next, I created two instances of the `User` class, `user_1` and `user_2`, with unique IDs and usernames. Then, I used the `follow` method to simulate `user_1` following `user_2`. This action increased `user_1`'s `following` count and `user_2`'s `followers` count by 1.

Finally, I printed the details of both users to observe the changes in their `followers` and `following` counts.

## Day 18

### Projects (Day 18)

#### [18. Damien Hirst Spots Paintings with Turtle Graphics](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-018/Projects/spots)

### Exercises (Day 18)

#### [A. Turtle Graphics Challenge](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-018/Exercises/1-turtle-challenge.py)

In this exercise, I delved into the creative and graphical aspect of Python programming using the Turtle Graphics library. This exercise was divided into multiple challenges, each aimed at exploring different functionalities of the Turtle module.

1. **Setting Up Turtle Graphics:**
   - I started by importing `Turtle` and `Screen` from the turtle module and `random` for generating random values. 
   - I created a turtle object named `tim` and set its shape to "turtle". I initially commented out lines to set the turtle's color and make it move in a square pattern.

2. **Creating Helper Functions:**
   - `random_color`: This function generates random colors by randomly selecting RGB values.
   - `calc_exterior_angles`: It calculates the exterior angles of a regular polygon based on the number of sides.
   - `random_angle`: This function returns a random angle in multiples of 90 degrees, useful for random movements.

3. **Drawing Shapes Challenge:**
   - I have commented out this challenge. The idea was to use a loop to draw regular polygons with sides ranging from 3 to 10. The `calc_exterior_angles` function would be used to calculate the turning angle for each side of these polygons, and `random_color` would give each shape a unique color.

4. **Random Walk Challenge:**
   - Also commented out, this challenge would have the turtle move randomly in straight lines, changing direction at random intervals. The direction changes would be multiples of 90 degrees, and each segment of the walk would be a different random color.

5. **Spirograph Challenge:**
   - This was the main focus of my code. Here, I set the turtle's speed to 10 for smoother animation. I used a while loop to draw a series of overlapping circles, each slightly rotated from the last, creating a spirograph-like pattern. For each circle, I changed the turtle's color using `random_color` and rotated it slightly to the right before drawing the next circle.

6. **Screen Settings:**
   - I set the screen's color mode to 255 to accommodate RGB color values. The `screen.exitonclick()` command was used to keep the window open until a click event, allowing observation of the final drawing.

Through this exercise, I learned how to use Turtle Graphics in Python for creating simple animations and drawings. It was a fun and visually engaging way to understand loops, functions, and the basics of computer graphics.

## Day 19

### Projects (Day 19)

#### [19a. Etch-a-Sketch](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-019/Projects/1-etch-a-sketch.py)

#### [19b. Turtle Race](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-019/Projects/2-turtle-race.py)

### Exercises (Day 19)

#### [A. Event Listeners](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-019/Exercises/1-event-listeners.py)

In this exercise, I explored the use of event listeners in Python, particularly within the context of the Turtle Graphics library. The primary focus was to understand how to respond to keyboard events and control the turtle using these inputs.

1. **Setting Up Turtle Graphics:**
   - I started by importing `Turtle` and `Screen` from the turtle module. 
   - I created a turtle object named `tim` and a screen object called `screen` to interact with.

2. **Defining Movement Function:**
   - I defined a function `move_forwards` that instructs the turtle to move forward by 10 units. This function serves as the event handler for a specific keyboard event.

3. **Setting Up Event Listener:**
   - I activated the screen's ability to listen for events using `screen.listen()`.
   - I then linked the pressing of the "space" key to the `move_forwards` function using `screen.onkey(fun=move_forwards, key="space")`. This means that whenever the space key is pressed, the `move_forwards` function will be called, causing the turtle to move forward.

4. **Screen Exit on Click:**
   - Finally, I used `screen.exitonclick()` to keep the turtle graphics window open until a mouse click event occurs. This allows for continuous interaction with the turtle until the user decides to close the window.

Through this task, I learned how to make Python programs interactive using event listeners. This is a fundamental concept in many graphical user interfaces and interactive applications.

## Day 20

### Projects (Day 20)

#### [20. Snake Game](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-020/Projects)

## Day 21

### Projects (Day 21)

#### [21. Snake Game v2 Upgrade](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-021/Projects)

### Exercises (Day 21)

#### [A. Class Inheritance](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-021/Exercises/1-class-inheritance.py)

In this exercise, I explored the concept of class inheritance in Python, which is a fundamental aspect of object-oriented programming. The task involved creating a base class `Animal` and a derived class `Fish` that inherits from `Animal`.

1. **Defining the Base Class:**
   - I started by defining the `Animal` class with a constructor (`__init__` method) initializing an attribute `num_eyes` set to 2.
   - I also defined a method `breathe` in the `Animal` class that prints "Inhale, exhale."

2. **Creating the Derived Class:**
   - Next, I created the `Fish` class, which inherits from the `Animal` class. Inheritance is indicated by specifying the parent class `Animal` in parentheses next to the class name `Fish`.
   - In the `Fish` class, I used `super().__init__()` in its constructor to ensure that it inherits all the properties and behaviors of the `Animal` class. This includes initializing the `num_eyes` attribute.

3. **Overriding and Extending Methods:**
   - I overrode the `breathe` method in the `Fish` class to add additional behavior. The `Fish` class's `breathe` method first calls the `breathe` method from the `Animal` class (using `super().breathe()`) to perform the basic breathing action, and then adds a print statement "Doing this underwater" to indicate its adaptation to an aquatic environment.
   - Additionally, I introduced a new method `swim` in the `Fish` class with a print statement "Moving in water." This method is specific to the `Fish` class and represents an ability not present in the `Animal` class.

4. **Creating an Instance and Testing Methods:**
   - I then created an instance of the `Fish` class named `nemo` and tested its methods and attributes.
   - I called `nemo.swim()`, which executed the `swim` method specific to the `Fish` class.
   - I called `nemo.breathe()`, which demonstrated the overridden behavior in the `Fish` class, showing both the inherited breathing action and the specialized "Doing this underwater" print statement.
   - Finally, I printed `nemo.num_eyes`, which confirmed that `nemo` inherited the `num_eyes` attribute from the `Animal` class.

Through this exercise, I gained a deeper understanding of how inheritance allows a class to inherit attributes and methods from a parent class, how to override methods in the child class, and how to add new methods specific to the child class.

#### [B. Slicing](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-021/Exercises/2-slicing.py)

In this exercise, I delved into the concept of slicing in Python, which is a technique used to access a subset of elements from a list or a similar sequence type. I worked with a list named `piano_keys`, representing the keys of a piano.

1. **Understanding the Basic Slice Notation:**
   - The slice notation in Python follows the format `[start:stop:step]`, where `start` is the index where the slice starts, `stop` is the index where the slice ends, and `step` is the interval between each element in the slice.

2. **Slicing Examples and Outputs:**
   - `piano_keys[2:5]`: This slice starts at index 2 and goes up to, but not including, index 5. The output is `['c', 'd', 'e']`.
   - `piano_keys[2:]`: Here, the slice starts at index 2 and goes to the end of the list. The output is `['c', 'd', 'e', 'f', 'g']`.
   - `piano_keys[:5]`: This slice includes elements from the beginning of the list up to, but not including, index 5. The output is `['a', 'b', 'c', 'd', 'e']`.
   - `piano_keys[1:6:2]`: This slice starts at index 1, ends at index 6, and takes every 2nd element. The output is `['b', 'd', 'f']`.
   - `piano_keys[::2]`: This slice includes the entire list, taking every 2nd element. The output is `['a', 'c', 'e', 'g']`.
   - `piano_keys[::-1]`: This is a special case that reverses the list. It starts from the end towards the first element with a step of -1. The output is `['g', 'f', 'e', 'd', 'c', 'b', 'a']`.

Through this task, I learned how slicing is a powerful tool for accessing parts of a sequence in Python. It can be used to extract elements, create sub-lists, and even reverse a list, all with concise and readable syntax. This concept is widely used in Python for various applications, including data manipulation and string handling.

## Day 22

### Projects (Day 22)

#### [22. PONG Game](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-022/Projects)

## Day 23

### Projects (Day 23)

#### [23. Turtle Crossing (Frogger Game)](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-023/Projects)

## Day 24

### Projects (Day 24)

#### [24a. Mail Merge](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-024/Projects/Mail%20Merge)

#### [24b. Snake Game](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-024/Projects/Snake%20Game)

### Exercises (Day 24)

#### [A. Read & Write Methods](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-024/Exercises/read_write.py)

In this exercise, I explored various methods to read from and write to files in Python, using the `open()` function with different modes and the `write()` and `read()` methods.

First, I used the `open()` function with the mode `"w"` for writing. This mode creates a new file or overwrites an existing file. I wrote a line of text to "data.txt" using `file.write("New line of text!")`.

Next, I appended another line to the same file using mode `"a"`, which stands for append. This mode adds content to the end of the file without deleting its existing content. I added "\nAnother line of text!" to "data.txt".

Then, I created a new file named "new_data.txt" by opening it in write mode. Since the file didn't exist, Python created it for me. I wrote two lines of text into this new file.

Lastly, I read the contents of "data.txt" using the default read mode, which is simply `open("data.txt")`. After reading the contents with `file.read()`, I printed them to the console.

This task taught me how to handle files in Python, including creating, writing, appending, and reading files. It demonstrated the importance of understanding file modes and the convenience of Python's context manager (`with` statement) for safe file handling, as it automatically closes the file after the block of code is executed, preventing potential file corruption or leaks.

## Day 25

### Projects (Day 25)

#### [25. United States Guessing Game](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-025/Projects/US%20States%20Game)

### Exercises (Day 25)

#### [A. Squirrel Census Data Exploration](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-025/Exercises/Squirrel%20Census)

In this Python exercise, I worked on exploring and processing data from the "2018 Central Park Squirrel Census" using the pandas library.

First, I imported the pandas library to handle the dataset. I read the data from "2018_Central_Park_Squirrel_Census.csv" into a DataFrame using `pandas.read_csv()`. This CSV file contained various details about each squirrel sighting, including their fur color.

My focus was on the "Primary Fur Color" column. I grouped the data by this column and used the `size()` function to count the number of squirrels of each fur color. This operation provided me with a Series object where the index was the fur color, and the values were the counts.

I then converted this Series into a DataFrame for better readability and manipulation. The DataFrame had two columns: "Primary Fur Color" and "Count", representing the fur color and the respective count.

Next, I sorted this DataFrame by the "Count" column in descending order to see which fur color was the most common. After sorting, I reset the index of the DataFrame with `reset_index(drop=True)` to have a clean, ordered index.

Finally, I saved this processed data into a new CSV file named "squirrel_count.csv" using `df.to_csv()`. This file succinctly summarized the count of squirrels by their primary fur color observed during the census.

Through this task, I learned to read, process, and group data using pandas, which is a powerful tool for data analysis in Python. It also demonstrated how to perform basic data manipulation operations like sorting and resetting indexes. The exercise was a practical application of pandas for real-world data exploration and summarization.

#### [B. Weather Data Exploration](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-025/Exercises/Weather)

In this Python exercise, I delved into exploring and manipulating weather data using the pandas library. The exercise involved various tasks, from reading CSV files to data manipulation and creating new data frames.

Initially, I experimented with basic file reading and CSV reading methods. I commented out the code where I read the "weather_data.csv" file line by line using `open()` and `readlines()`, and also the section where I read the same file using the `csv` module to extract temperature data.

Then, I shifted to using pandas, which is a more powerful and convenient tool for data analysis. I imported the pandas library and read the "weather_data.csv" file into a DataFrame using `pandas.read_csv()`. I explored the types of data structures returned by pandas, like DataFrames and Series, by checking the type of `data` and `data["temp"]`.

I converted the entire DataFrame and the temperature column into a dictionary and a list, respectively, using `to_dict()` and `to_list()`. These operations demonstrated different ways of viewing and manipulating data in pandas.

I then calculated the mean and the maximum temperature directly from the DataFrame without needing to manually convert the temperatures into a list, showcasing pandas' built-in statistical functions.

Additionally, I extracted data based on specific conditions. For instance, I retrieved rows where the day was "Monday" and where the temperature was the maximum in the dataset. This part of the exercise highlighted how to filter and access specific rows in a DataFrame.

I also implemented a custom function `CelsiusToFahrenheit` to convert temperature from Celsius to Fahrenheit. I applied this function to the temperature of Monday, demonstrating how to perform custom operations on DataFrame values.

Lastly, I created a new DataFrame from scratch using a dictionary. This new DataFrame contained student names and their scores. I then exported this DataFrame to a new CSV file named "score_data.csv", illustrating how to create and write DataFrames to CSV files.

## Day 26

### Projects (Day 26)

#### [26. NATO Alphabet Translator](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-026/Projects/NATO%20Alphabet)

### Exercises (Day 26)

#### [A. List Comprehension](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-026/Exercises/1-list-comprehension.py)

In this exercise, I learned about list comprehensions in Python, a concise way to create lists. The concept involves constructing a list by iterating over an iterable and optionally applying a condition or operation.

1. First, I created a new list, `new_numbers`, by adding 1 to each element in the original list `numbers`. This was done using the list comprehension `[num + 1 for num in numbers]`.

2. Next, I converted each letter in the string `name` into a list of letters using `[letter for letter in name]`. This demonstrated how list comprehensions can be used with strings.

3. I then worked with a range object, `range_nums`. I created `range_list`, where each number in the range is multiplied by 2, through the comprehension `[n * 2 for n in range_nums]`.

4. In a more complex example, I filtered and transformed elements from a list of names. For `names_list`, I used a condition to include only names with 4 or fewer characters `[name for name in names if len(name) <= 4]`.

5. Finally, I created `upper_names_list` by converting names longer than 4 characters to uppercase. This was done using `[name.upper() for name in names if len(name) >= 5]`.

#### [B. Squaring Numbers](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-026/Exercises/2-squaring-numbers.py)

In this exercise, I practiced using list comprehensions to square each number in a given list. The objective was to transform a list of numbers by squaring each element, all in a single line of code.

The original list, `numbers`, contained a sequence of integers. To achieve the task, I wrote the following list comprehension: `squared_numbers = [num**2 for num in numbers]`. This line of code iterates over each element `num` in the `numbers` list and applies the squaring operation (`num**2`).

When printed, `squared_numbers` displayed the squared value of each number from the original list. This was a straightforward yet effective exercise to understand how list comprehensions can be used for mathematical operations on list elements, showcasing the elegance and power of Python for such operations. It also reinforced the concept that list comprehensions are an efficient way to create new lists by applying an expression to each item in an existing list.

#### [C. Filter Even Numbers](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-026/Exercises/3-filter-even-nums.py)

In this exercise, I focused on filtering elements in a list using a list comprehension in Python, specifically to extract even numbers from a given list.

Given the list `numbers`, which contained a series of integers, I wrote a one-liner list comprehension to create a new list, `result`, containing only the even numbers from the original list. The code for this was `[num for num in numbers if num % 2 == 0]`. This expression iterates through each number in `numbers`, and includes it in `result` if it satisfies the condition `num % 2 == 0` (which checks if the number is even).

Upon executing the code and printing `result`, the output was a list of all even numbers from the original `numbers` list.

#### [D. Dictionary Comprehension](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-026/Exercises/4-dict-comprehension.py)

In this exercise, I learned about dictionary comprehensions, a powerful way to create and manipulate dictionaries dynamically. The task involved generating random scores for a list of students and then filtering those scores to identify students who passed.

1. I started with a list of student names, `names`.

2. I defined a function `RandomScore()` that generates a random score between 1 and 100 using `random.randint(1, 100)`.

3. Using dictionary comprehension, I created a dictionary `student_scores` where each student's name from the `names` list was a key, and their associated value was a random score generated by the `RandomScore()` function. The comprehension was `{name: RandomScore() for name in names}`.

4. To identify students who passed (assuming a passing score is 60 or above), I used another dictionary comprehension to filter `student_scores`. The comprehension was `{student: score for (student, score) in student_scores.items() if score >= 60}`. This created a new dictionary `passed_scores` containing only the students who had scores of 60 or above.

#### [E. Word Length Dictionary](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-026/Exercises/5-word-length-dict.py)

In this exercise, I created a program to generate a dictionary that maps words in a sentence to their respective lengths. The task involved string manipulation and comprehension in Python.

The program starts with a predefined sentence: "What is the Airspeed Velocity of an Unladen Swallow?". Using the `split()` method on this string, I broke it into a list of words, stored in `word_list`. This method splits a string into a list where each word is an item, based on spaces.

Next, I utilized a dictionary comprehension to create a dictionary, `result`, where each key-value pair consists of a word from `word_list` and its corresponding length. The comprehension iterates over each word in `word_list`, using the `len()` function to get the length of each word.

Finally, the program prints the `result` dictionary. This displays each word from the original sentence alongside the number of characters it contains.

#### [F. Weather Dictionary](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-026/Exercises/6-weather-dict.py)

In this exercise, I created a Python program to convert temperatures from Celsius to Fahrenheit for a weekly weather report. This task involved writing a function for the conversion and applying it to a dictionary using comprehension.

The program starts with a predefined dictionary, `weather_c`, containing days of the week as keys and their corresponding temperatures in Celsius as values. My task was to convert these temperatures to Fahrenheit.

I wrote a function named `CelsiusToFahrenheit` that takes a temperature in Celsius as its argument. The function applies the formula for converting Celsius to Fahrenheit: `(Celsius temperature * 9/5) + 32`.

Next, I used a dictionary comprehension to create a new dictionary, `weather_f`. This comprehension iterates over each key-value pair in `weather_c` (representing day and Celsius temperature). It applies the `CelsiusToFahrenheit` function to each temperature value and pairs it with the corresponding day.

Finally, the program prints `weather_f`, displaying the days of the week with their temperatures in Fahrenheit.

This exercise demonstrated practical uses of functions, dictionary comprehensions, and the concept of iterating over key-value pairs in a dictionary. It also reinforced the application of mathematical formulas in programming.

#### [G. Data Overlap Exercise](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-026/Exercises/Data%20Overlap%20Exercise)

In this exercise, I worked on a Python program to find overlapping data between two files and then sort the results. The task involved file handling, set operations, list comprehension, and sorting.

The program begins by reading the contents of two text files, `file1.txt` and `file2.txt`. Each file contains a list of numbers, one per line. I used the `with open()` statement to open and read the contents of each file, storing them in `file_1_contents` and `file_2_contents` respectively.

After reading the files, I converted the contents of each file into a set using the `split()` method. This method splits the file contents into a list of strings (based on new lines), and `set()` converts these lists into sets, named `numbers_1` and `numbers_2`. The use of sets here is crucial as they automatically remove duplicates and allow for efficient comparison.

Next, I used list comprehension to create a list named `result`. This list is composed of the common elements between `numbers_1` and `numbers_2`. The comprehension iterates over each element in `numbers_1`, checking if it also exists in `numbers_2`. Each common element is converted to an integer before being added to the list.

Then, I sorted `result` in ascending order using the `sorted()` function with `reverse=False`. This rearranges the numbers from the smallest to the largest.

Finally, the program prints the sorted list `result`, which contains the numbers that are present in both files.

This exercise showcased practical applications of file reading, data type conversion, set operations for finding intersections, and sorting techniques in Python. It illustrated how to efficiently process and compare data from different sources.

#### [H. Pandas DataFrame Iterate](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-026/Exercises/Pandas%20DataFrame%20Iterate)

In this exercise, I explored how to iterate over rows in a Pandas DataFrame in Python. This task was centered around creating a DataFrame from a dictionary and then using a loop to access and print specific data from it.

The program starts by importing the Pandas library, essential for data manipulation and analysis in Python. I then created a dictionary named `student_dict` with two keys: "student" and "score". Each key maps to a list of values representing student names and their corresponding scores.

Next, I used this dictionary to create a Pandas DataFrame called `student_data_frame`. A DataFrame is a two-dimensional, size-mutable, and potentially heterogeneous tabular data structure with labeled axes (rows and columns). It's a fundamental component in Pandas and is useful for representing and manipulating structured data.

The core part of this exercise was to loop through each row in the DataFrame. I used `student_data_frame.iterrows()`, a function that provides an iterator yielding index and row data for each row. In each iteration, `index` represents the index of the row, and `row` is a series containing the row data.

Inside the loop, I printed the values of `row.student` and `row.score`. This demonstrated how to access specific columns in each row of a DataFrame. The commented-out code, which checks if the student's name is "Jordan" and then prints their score, illustrated conditional data access within the DataFrame.

Through this exercise, I learned about data manipulation using Pandas, particularly the creation of DataFrames from dictionaries and iterating over DataFrame rows. It was a practical demonstration of handling tabular data, accessing specific data points, and conditional logic in the context of data analysis.

## Day 27

### Projects (Day 27)

#### [27. Unit Converter App - (Miles to Kilometers)](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-027/Projects/6-miles-km-converter.py)

### Exercises (Day 27)

#### [A. Windows & Labels](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-027/Exercises/1-windows-labels.py)

In this exercise, I created a basic Graphical User Interface (GUI) application using Python's Tkinter library. This program demonstrates the creation of a window, adding widgets like labels and buttons, and updating the label text dynamically based on user interaction.

The program begins by importing the Tkinter library, which is a standard Python interface to the Tk GUI toolkit. I then created a main window for the application using `Tk()`, setting its title to "Python GUI Program" and minimum size to 500x400 pixels.

A label widget, `my_label`, is created with the initial text "I am a label!", using the Arial font at size 24 and bold style. This label is then packed into the window, which means it is added to the window and displayed. The text of the label is changed twice, first to "New Label Text!" and then to "Yet Another Label!" using different methods (`my_label["text"]` and `my_label.config(text=...)`).

Two functions are defined: `button_clicked()` and `input_label()`. `button_clicked()` is designed to update the label text to indicate the number of times a button has been clicked, but it's not used in this program. `input_label()`, on the other hand, updates the label text with the value entered in an input field.

A button widget, `button`, is created with the label "Button!" and is configured to call `input_label()` when clicked. This button is packed into the window below the label. An input field (Entry widget) is also created and packed into the window.

The `window.mainloop()` at the end of the script keeps the window open, allowing for user interaction. Whenever the button is clicked, the text in the input field is used to update the label's text.

Through this exercise, I learned about the basics of creating a GUI in Python using Tkinter, including window creation, adding and configuring widgets, and handling user events and interactions. This program provided a practical introduction to building interactive applications with graphical elements.

#### [B. Many Arguments](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-027/Exercises/2-many-arguments.py)

In this exercise, I explored the use of `*args` in Python, which allows a function to accept an arbitrary number of arguments. I applied this concept in creating a function named `add` that sums up all the arguments provided to it.

Firstly, the `add` function prints the second item in the `args` tuple, demonstrating how individual elements can be accessed. The `args` variable is a tuple containing all the arguments passed to the function.

I then initialized a variable `sum_args` to 0 to keep track of the sum. Using a `for` loop, I iterated over each argument in `args` and added it to `sum_args`. This loop effectively accumulates the sum of all provided arguments.

The function finally returns the total sum. When tested with the input `add(5, 6, 11)`, it correctly calculated and returned the sum of these numbers.

Through this task, I learned about using `*args` for variable-length argument lists and how to manipulate these arguments within a function. This is particularly useful for creating flexible functions that can handle an unknown number of inputs.

#### [C. Many Keyword Arguments](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-027/Exercises/3-many-keyword-args.py)

In this exercise, I delved into the use of `**kwargs` in Python, which enables a function to accept an arbitrary number of keyword arguments. This was demonstrated through two examples: a `calculate` function and the creation of a `Car` class.

##### The `calculate` Function:
- The `calculate` function accepts a standard argument `n` and any number of keyword arguments (`**kwargs`).
- Initially, I printed the `kwargs` to see how Python stores these keyword arguments as a dictionary.
- The function then modifies `n` by adding and multiplying it with values associated with the 'add' and 'multiply' keys in `kwargs`. This showcases how to access and use the values from the `kwargs` dictionary.
- Testing this function with `calculate(2, add=3, multiply=5)` showed how it dynamically adjusts its behavior based on the provided keyword arguments.

##### The `Car` Class:
- I then created a `Car` class where the constructor (`__init__`) uses `**kw` to accept various attributes of a car.
- The class uses the `get` method on the `kw` dictionary to safely assign values to the car's attributes like `make`, `model`, `color`, and `seats`. This method avoids errors if certain attributes are not provided.
- By creating an instance of `Car` with specific attributes, I demonstrated how flexible and adaptable the class is to different sets of data.
- Finally, I printed the attributes of `my_car` to confirm that the class correctly assigns and stores the provided information.

#### [D. Tkinter Widgets](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-027/Exercises/4-tkinter-widgets.py)

In this exercise, I explored various widgets in Tkinter, a popular GUI toolkit in Python, to create an interactive window application. The exercise was a comprehensive introduction to basic GUI elements and their functionalities.

1. **Window Configuration**: I started by creating a new window using `Tk()`, setting its title, and specifying minimum dimensions.

2. **Labels**: I used the `Label` widget to display text. Initially, I set some text and then changed it using the `config` method.

3. **Buttons**: I created a `Button` widget and linked it to a function called `action`, which executes when the button is clicked.

4. **Entries**: The `Entry` widget allowed for single-line text input. I pre-populated it with some text and learned how to retrieve the input value.

5. **Text**: For multi-line text entry, I used the `Text` widget. I added initial text and fetched the current text, understanding its line and character indexing system.

6. **Spinbox**: This widget let users pick from a range of numbers. I connected it to a function that prints the selected value.

7. **Scale**: The `Scale` widget provided a slider interface. I used a function to display the current value as it changes.

8. **Checkbutton**: I created a checkbutton that toggles between two states, learning to use `IntVar` to track its state and execute a function on change.

9. **Radiobuttons**: I used two `Radiobutton` widgets, each tied to the same variable but representing different values, and printed the selected option through a function.

10. **Listbox**: Finally, I added a `Listbox` to display a list of items (fruits) and implemented a function to print the currently selected item.

With this task, I gained hands-on experience with Tkinter's fundamental widgets, understanding how to layout a basic GUI, handle user interactions, and retrieve data from various input elements. This exercise was an excellent foundation for building more complex graphical user interfaces in Python.

#### [E. Layout Managers](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-027/Exercises/5-layout-managers.py)

In this exercise, I explored the layout managers in Tkinter, which are essential for arranging widgets in a Python GUI application. I worked with grid, pack, and place layout managers to understand their differences and use cases.

1. **Window Setup**: I started by creating a Tkinter window, setting its title, and configuring its minimum size and padding.

2. **Label**: I used a `Label` widget to display text and learned how to modify its text and appearance. I experimented with different layout managers (commented out `pack` and `place`) but ultimately placed it using `grid` with specified row and column.

3. **Buttons**: Two buttons were created, each connected to a different function. The first button, when clicked, updated the label with the text from an entry widget. The second button displayed a count of how many times it was clicked, updating the label text accordingly. I placed these buttons using the `grid` layout manager.

4. **Entry**: An entry widget for text input was added. Similar to the other widgets, I placed it using `grid`.

5. **Understanding Layout Managers**:
    - **Pack**: This manager organizes widgets in a block, which means they occupy space along their parent container's vertical or horizontal box. I saw this in the commented-out `pack` code.
    - **Grid**: This manager places widgets in a two-dimensional grid. It is more versatile than `pack` for complex layouts. I used `grid` for precise positioning of labels and buttons in specified rows and columns.
    - **Place**: This manager positions widgets by defining their exact x and y coordinates. I saw its usage in the commented code, which provided an idea of absolute positioning.

I gained a deeper understanding of how different layout managers affect the placement and arrangement of widgets in a Tkinter application. This is very important for creating visually appealing and functionally organized GUIs. The exercise effectively demonstrated the flexibility and specific use cases of each layout manager in Python's Tkinter module.

## Day 28

### Projects (Day 28)

#### [28. Pomodoro Timer](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-028/Projects/Pomodoro%20Timer)

## Day 29

### Projects (Day 29)

#### [29. Password Manager](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-029/Projects/Password%20Manager)

## Day 30

### Exercises (Day 30)

#### [A. Catching Exceptions](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-030/Exercises/1-catching-exceptions.py)

In this exercise, I learned about handling exceptions in Python, which are crucial for writing robust and error-resistant programs. The code snippets provided cover various common exceptions and demonstrate how to manage them effectively using `try`, `except`, `else`, and `finally` blocks.

1. **FileNotFoundError**: When trying to read a file that doesn't exist (`a_file.txt`), I learned to catch this exception. If the file is not found, it's created and written to, preventing the program from crashing.

2. **KeyError**: I learned to handle cases where a key is not found in a dictionary. For instance, attempting to access a non-existent key (`"non-existent-key"`) in `a_dictionary` triggers a KeyError, which I learned to catch and print a custom error message.

3. **TypeError**: I discovered how to deal with operations on incompatible types, such as adding a number to a string (`text + 5`), which is not allowed in Python.

4. **ValueError and Custom Exception**: In the BMI calculator part, I learned how to raise a custom exception (`ValueError`) when the user enters an unrealistic height (over 3 meters). This is a good practice for validating user input.

5. **General Exception Handling Structure**: The `try` block contains code that might cause an exception, while the `except` block handles specific exceptions. The `else` block executes if no exceptions occur, and `finally` ensures some code runs no matter what (like closing a file). The exercise also included an example of intentionally raising an exception (`raise TypeError`) in the `finally` block.

Overall, this task highlighted the importance of anticipating and managing errors in Python, showcasing various scenarios where exception handling is essential. This is a fundamental skill for developing resilient and user-friendly Python applications.

#### [B. Index Error Handling](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-030/Exercises/2-index-error-handling.py)

In this exercise, I learned how to handle IndexError exceptions in Python, specifically in the context of accessing list elements. The task involved modifying a function, `make_pie`, to catch and handle an IndexError when an invalid index is passed to it.

1. **Understanding IndexError**: Initially, the `make_pie` function attempted to access an element in the `fruits` list using a provided index. However, if the index was out of range (like 4 in this case, where the list has only three elements), an IndexError would occur. This is a common error when working with lists or arrays.

2. **Adding Exception Handling**: To prevent the program from crashing due to an IndexError, I added a `try` block around the code that might cause the exception. In the `except` block, I caught the IndexError and implemented an alternative action: printing "Fruit pie" and returning this string. This way, the program continues to run smoothly even when an invalid index is used.

3. **Testing the Function**: After modifying `make_pie`, I tested it by calling it with an index that I knew would cause an IndexError (4). The exception handling worked as expected, printing "Fruit pie" instead of causing a crash.

4. **Redundant Outer Try-Except Block**: The outer `try` and `except` blocks around the `make_pie(4)` call became redundant after adding the exception handling inside the `make_pie` function. Since the function already handles the IndexError internally, there is no need for additional error handling outside the function.

#### [C. Key Error Handling](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-030/Exercises/3-key-error-handling.py)

In this exercise, I explored handling KeyError exceptions in Python, specifically while working with a list of dictionaries. The task involved iterating through `facebook_posts`, a list of dictionaries, and summing up the "Likes" from each post.

1. **Understanding KeyError**: A KeyError occurs when trying to access a key in a dictionary that does not exist. In this case, some dictionaries in the `facebook_posts` list did not have the "Likes" key, which could potentially lead to a KeyError when the code tries to access `post["Likes"]`.

2. **Implementing Exception Handling**: To address this, a `try` block was used around the code that could raise the KeyError (accessing `post["Likes"]`). In the `except` block, I caught the KeyError and used a `pass` statement to do nothing in cases where the "Likes" key is missing. This prevented the program from crashing and allowed it to continue iterating through the list.

3. **Accumulating Likes**: The `total_likes` variable was used to accumulate the count of "Likes" from each post. If a post did not have the "Likes" key, the KeyError was caught, and the loop continued to the next post without modifying `total_likes`.

4. **Result Output**: After iterating through all the posts, the total number of likes was printed out. This gave a sum of likes from posts that contained the "Likes" key, safely ignoring those that didn't.

## Day 31

### Projects (Day 31)

#### [31. Flashcards GUI Application](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-031/Projects/Flashcards%20App)

## Day 32

### Projects (Day 32)

#### [32. Calculator GUI App](https://github.com/itsjordanmuller/2023-python-100-days/blob/main/Day-032/Projects/Calculator%20App/main.py)

## Day 33

### Projects (Day 33)

#### [33. Calculator GUI App v2 Upgrade](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-033/Projects/Calculator%20App)

## Day 34

### Projects (Day 34)

#### [34. Quizzler Quiz App - GUI Application](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-034/Projects/Quizzler)

## Day 35

### Projects (Day 35)

#### [35. Quizzler Quiz App v2 Upgrade - GUI Application](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-035/Projects/Quizzler)

## Day 36

### Projects (Day 36)

#### [36. Tic-Tac-Toe App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-036/Projects/Tic-Tac-Toe)

## Day 37

### Projects (Day 37)

#### [37. Habit Tracker App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-037/Projects/Habit%20Tracker%20App)

## Day 38

### Projects (Day 38)

#### [38. Tic-Tac-Toe App v2 Upgrade](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-038/Projects/Tic-Tac-Toe)

## Day 39

### Projects (Day 39)

#### [39. Rock Paper Scissors - GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-039/Projects/Rock%20Paper%20Scissors%20App)

## Day 40

### Projects (Day 40)

#### [40. Rock Paper Scissors v2 Upgrade - GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-040/Rock%20Paper%20Scissors%20App)

## Day 41

### Projects (Day 41)

#### [41. Introduction to HTML](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-041/Projects/Introduction%20to%20HTML)

### Exercises (Day 41)

#### [A. Heading Elements](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-041/Exercises/Heading%20Element)

In this exercise, I explored the basics of HTML, particularly focusing on using heading elements to structure content. The HTML document starts with the standard `<!DOCTYPE html>` declaration and includes language, character encoding, and viewport meta tags in the `<head>` section, ensuring proper rendering and accessibility.

The main learning point was the use of different heading levels (`<h1>` through `<h4>`) in the `<body>` section. I created a hierarchy of headings to represent a book's structure: the `<h1>` tag for the book title, `<h2>` tags for chapters, `<h3>` tags for sections within chapters, and an `<h4>` tag for a diagram within a section.

This structure not only provided a clear visual representation of the book's organization but also demonstrated the semantic importance of using headings correctly in HTML. It highlighted how headings help in defining the document's structure and outline, making it more readable and accessible, especially for screen readers and search engines.

Overall, this exercise was an effective introduction to HTML headings and their role in creating well-structured, accessible web content.

#### [B. Paragraph Elements](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-041/Exercises/Paragraph%20Element)

In this HTML exercise, I learned how to use paragraph elements to structure text content within a webpage. The HTML document begins with the standard declaration and includes essential meta tags in the `<head>` section, ensuring proper encoding and responsive design.

The key focus was on the `<p>` tag, used to define paragraphs in the `<body>` section. I created three distinct paragraphs, each enclosed in its own `<p>` element. These paragraphs contained a block of Lorem Ipsum text, a common placeholder text in the design and typesetting industry.

This exercise demonstrated the importance of the paragraph element in HTML for organizing and presenting text content in a readable and structured manner. Using `<p>` tags helps in creating clear divisions between different blocks of text, enhancing the overall readability and aesthetic appeal of the webpage.

Through this task, I gained practical experience in formatting text content on a webpage, understanding the role of paragraph elements in HTML, and the significance of clean, well-organized content structure for user experience and accessibility.

#### [C. Void Elements](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-041/Exercises/Void%20Elements)

In this HTML exercise, I learned about void elements, which are special HTML elements that do not require a closing tag. The exercise focused on two such elements: `<br>` and `<hr>`.

The document structure follows the standard HTML5 template, including the DOCTYPE declaration, language attribute, character encoding, and viewport settings for responsiveness. The content is organized within the `<body>` tag, starting with a `<h1>` heading for the title "William Blake."

The first key learning was the use of the `<br>` (break) element within a paragraph. This element is used to create a line break in the text, which I applied in an address format. By inserting `<br>` tags after each line of the address, I was able to format the address properly, with each part starting on a new line.

The second key element was the `<hr>` (horizontal rule) tag, which creates a thematic break or a horizontal line in the document. I used it to visually separate the address from the biographical paragraph about William Blake, enhancing the readability and aesthetic appeal of the page.

Through this exercise, I gained a practical understanding of how void elements work in HTML and how they can be used to format content effectively. It highlighted the importance of these elements in controlling the layout and flow of text on a webpage, contributing to a better user experience and content presentation.

## Day 42

### Projects (Day 42)

#### [42. Birthday Invite Project](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-042/Projects/Birthday%20Invite%20Project)

### Exercises (Day 42)

#### [A. Anchor Elements](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-042/Exercises/Anchor%20Elements)

In this exercise, I began to use anchor elements in HTML to create hyperlinks. The HTML document is structured with standard elements including the DOCTYPE declaration, meta tags for character encoding and viewport settings, and a meaningful title in the `<head>` section.

The main focus was on creating a list of hyperlinks using the `<a>` (anchor) tag. The body of the document features a heading `<h1>` that introduces the list as "My Top 5 Favorite Websites." I then used an ordered list `<ol>` to enumerate the websites. Each list item `<li>` contains an anchor element. The anchor elements are written as `<a href="URL">Link Text</a>`, where `href` is an attribute specifying the URL of the page the link goes to, and the link text is the clickable text that appears to the user.

For example, `<a href="https://www.producthunt.com/">Product Hunt</a>` creates a hyperlink to the Product Hunt website, with "Product Hunt" as the clickable text. This pattern is repeated for each favorite website, creating an interactive list where each item is a link to a different website.

#### [B. Boilerplate](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-042/Exercises/Boilerplate)

In this exercise, I learned about the basic structure of an HTML document, often referred to as the "boilerplate". This boilerplate is the foundation for creating web pages and includes essential elements that define the document's type, language, character encoding, viewport settings, and the document title.

1. **DOCTYPE Declaration**: `<!DOCTYPE html>` is the first line of the document, declaring the document type and version of HTML being used. In this case, it specifies HTML5, the latest standard.

2. **HTML Element with Language Attribute**: The `<html lang="en">` tag defines the root of the HTML document and includes a language attribute (`lang="en"`) specifying that the document is in English. This is important for accessibility and search engine optimization.

3. **Head Section**: Inside the `<head>` tag, several key elements are included:
   - **Meta Charset**: `<meta charset="UTF-8" />` sets the character encoding to UTF-8, which includes most characters from all known human languages, making the content more universally readable and preventing text display issues.
   - **Meta Viewport**: `<meta name="viewport" content="width=device-width, initial-scale=1.0" />` is crucial for responsive web design. It ensures that the page scales correctly on different devices, especially on mobile screens.
   - **Title**: `<title>Document</title>` sets the title of the web page, which appears in the browser tab and is used by search engines.

4. **Body Section**: The `<body>` tag is where the content of the HTML document that will be visible to users is placed. In this boilerplate, the body is empty, serving as a placeholder for future content.

#### [C. Image Elements](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-042/Exercises/Image%20Elements)

In this HTML exercise, I learned how to incorporate image elements into a webpage and use basic CSS for layout styling. The exercise focused on displaying two images, one of a kitten and one of a puppy, in a two-column layout.

1. **Image Elements**: The `<img>` tag is used to embed images. Each image element has a `src` attribute specifying the URL of the image and an `alt` attribute providing alternative text for screen readers or in cases where the image cannot be displayed. For example, `<img src="URL" alt="Description">`.

2. **CSS Styling**: The `<style>` tag in the head section contains CSS to style the webpage. 
   - The `.two-columns` class applies a flexbox layout to display content in two columns.
   - The `.column` class ensures each column has equal width and margin.
   - The `img` selector styles all images to have a maximum width of 100% of their container and automatic height to maintain aspect ratio.

This exercise was an excellent introduction to adding and styling images in HTML, demonstrating the use of the `<img>` tag and basic CSS. It highlighted the importance of responsive images in web design and provided practical experience in creating visually appealing and accessible web content.

#### [D. List Elements](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-042/Exercises/List%20Elements)

In this HTML exercise, I learned how to create and format lists using unordered (`<ul>`) and ordered (`<ol>`) list elements. The exercise involved creating a web page for "Jordan's Cinnamon Roll Recipe," with sections for ingredients and instructions.

1. **Unordered Lists for Ingredients**: I used `<ul>` tags to create lists of ingredients for both the dough and the filling. Each ingredient is listed within a `<li>` (list item) tag. Unordered lists are typically used when the order of items is not important.

2. **Ordered List for Instructions**: The instructions are organized in an ordered list `<ol>`, where each step in the recipe is placed in a `<li>` tag. Ordered lists are appropriate here as the sequence of steps is crucial for the recipe's success.

3. **Section Headings**: The document uses `<h1>`, `<h2>`, and `<h3>` tags for headings and subheadings, providing a clear structure and hierarchy to the content.

#### [E. Nesting and Indentation](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-042/Exercises/Nesting%20and%20Indentation)

In this exercise, I learned about nesting and indentation, two crucial aspects of writing clean, readable, and well-structured HTML code. The exercise involved creating a list with multiple levels of nested sub-lists, demonstrating how elements can be nested within each other to represent hierarchical relationships in content.

1. **Nesting Elements**: The main list is an unordered list (`<ul>`), containing several list items (`<li>`). Within these list items, I nested ordered lists (`<ol>`) and additional unordered lists to create a hierarchy. For example, under the list item "B", there's an ordered list with items "B1" and "B2", and under "B2", there are further nested unordered lists with items "B2a", "B2b", etc.

2. **Proper Indentation**: Each nested element is indented relative to its parent element. This indentation is not just for aesthetics; it makes the structure of the HTML document clear and understandable. For instance, the nested lists under "B2" are indented more than "B2" itself, clearly showing their relationship in the hierarchy.

3. **Hierarchy Representation**: The exercise demonstrates how to represent hierarchical data in HTML using nested lists. The depth of nesting effectively shows the relationship between different items and sub-items.

This exercise was essential in understanding how nesting and indentation work in HTML, showing the importance of these practices in creating well-organized and easily navigable web content.

## Day 43

### Projects (Day 43)

#### [43. Color Vocabulary Project](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-043/Projects/Color%20Vocab%20Project)

### Exercises (Day 43)

#### [A. Adding CSS](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-043/Exercises/Adding%20CSS)

In this exercise, I explored the three primary methods of adding CSS to an HTML document: inline, internal, and external styling. Each method has its own use cases and benefits.

1. **Inline CSS**: 
   - In `inline.html`, CSS is applied directly to HTML elements using the `style` attribute. 
   - Example: `<h1 style="color: blue">Style Me in Blue!</h1>` applies a blue color to the heading.
   - Inline CSS is useful for quick, one-off styling but lacks scalability and can lead to cluttered HTML.

2. **Internal CSS**: 
   - In `internal.html`, CSS is included within a `<style>` tag in the `<head>` section of the HTML document. 
   - Example: `h1 { color: red; }` styles all `<h1>` elements in red.
   - Internal CSS is good for single-page styles but doesn't promote reuse across multiple pages.

3. **External CSS**: 
   - In `external.html`, CSS is defined in a separate file (`style.css`) and linked to the HTML document using a `<link>` tag.
   - Example: The `style.css` file contains `h1 { color: green; }`, which styles all `<h1>` elements in green.
   - External CSS is the most efficient method for styling large websites, as it keeps HTML and CSS separate and allows for style reuse across multiple pages.

This exercise was instrumental in understanding the different ways to apply CSS to HTML documents. It highlighted the importance of choosing the appropriate method based on the project's scope and the need for maintainability and scalability in web development. It also demonstrated how CSS enhances the visual presentation of web pages, making them more appealing and user-friendly.

#### [B. CSS Selectors](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-043/Exercises/CSS%20Selectors)

In this exercise, I learned about different types of CSS selectors and how they are used to apply styles to HTML elements. The HTML document `index.html` provided the structure to demonstrate each selector type, and the corresponding CSS in `style.css` applied specific styles based on these selectors.

1. **Element Selector**: 
   - Targets elements based on their HTML tag name.
   - Example: `p { color: red; }` applies red color to all paragraph (`<p>`) elements.

2. **Class Selector**: 
   - Targets elements based on the value of their `class` attribute.
   - Example: `.note { font-size: 20px; }` sets the font size to 20px for all elements with a class of "note".

3. **ID Selector**: 
   - Targets an element based on the value of its `id` attribute.
   - Example: `#id-selector-demo { color: green; }` applies green color to the element with the id "id-selector-demo".

4. **Attribute Selector**:
   - Targets elements based on their attributes and values.
   - Example: `li[value="4"] { color: blue; }` applies blue color to `<li>` elements that have the `value` attribute set to "4".

5. **Universal Selector**:
   - Targets all elements.
   - Example: `* { text-align: center; }` centers the text of all elements on the page.

## Day 44

### Projects (Day 44)

#### [44. Motivational Meme Website](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-044/Projects/Motivation%20Meme%20Project)

### Exercises (Day 44)

#### [A. CSS Box Model](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-044/Exercises/CSS%20Box%20Model)

In this HTML and CSS exercise, I explored the CSS Box Model, a fundamental concept in web design that defines how different parts of a webpage's layout work together. The exercise involved creating three boxes with different styles to understand how padding, borders, and margins interact.

1. **Box Creation and Sizing**:
   - Three `<div>` elements with the class `.box` were created, each set to a height and width of 200px.

2. **Styling and Background Colors**:
   - Each box was given a distinct background color (`cadetblue`, `gold`, and `indianred`).

3. **Padding and Border**:
   - The first box (`.green`) was styled with 20px padding and a 10px solid black border.
   - The paragraph inside the first box had its margin set to 0 to remove any default spacing.

4. **Different Border Sizes**:
   - The second box (`.yellow`) had a varying border thickness, with 20px on the top and bottom, and 10px on the left and right sides.

5. **Margin Adjustment**:
   - Margins were adjusted to ensure the corners of each box touched. The `.yellow` box was shifted to the right by setting its left margin to 260px, and the `.red` box was slightly shifted by setting its left margin to 40px.

#### [B. CSS Colors](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-044/Exercises/CSS%20Colors)

In this exercise, I learned about applying different color styles using CSS. The exercise involved styling the background of the webpage and the text and background colors of headings (`<h1>` and `<h2>`).

1. **Webpage Background Color**:
   - The background of the entire webpage was set to "antiquewhite" using `body { background-color: antiquewhite; }`. This changes the background color of the entire page.

2. **Heading (`<h1>`) Styles**:
   - The `<h1>` element was styled with two color properties: `color: whitesmoke;` for the text color and `background-color: darkseagreen;` for the background color of the heading.

3. **Heading (`<h2>`) Styles**:
   - The `<h2>` element received a similar treatment with different colors: `color: #faf8f1;` for the text color (using a hex color code) and `background-color: #c58940;` for the background color.

These styles were directly applied within a `<style>` tag in the head of the HTML document, demonstrating how CSS can be used to enhance the visual presentation of web content.

This exercise was particularly useful for understanding how to use CSS for coloring and how different color formats (like named colors, hex codes) can be applied in web design. It highlighted the importance of color in creating visually appealing and accessible web pages.

#### [C. Font Properties](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-044/Exercises/Font%20Properties)

In these exercises, I learned about various font properties in CSS, how to apply them, and their effects on the appearance of text in a webpage. The exercises were divided into two parts: exploring different font sizes and experimenting with various font families.

1. **Font Properties (index.html)**:
   - **Color**: The `color` property was used to change the text color of a paragraph to coral.
   - **Size**: The `font-size` property, using `rem` units, was applied to change the size of the text to twice the root font size.
   - **Weight**: The `font-weight` property was set to 900, making the text bold.
   - **Family**: The `font-family` property was used to apply the Google font "Caveat" to a paragraph.
   - **Align**: The `text-align` property was used to right-align a paragraph.

2. **Font Size (font-size.html)**:
   - This part of the exercise involved using different units for font sizes, including pixels (`px`), points (`pt`), `em`, and `rem`.
   - The `font-size` property was applied to various paragraphs to demonstrate how each unit influences the size of the text.

3. **Font Family (font-family.html)**:
   - This exercise demonstrated the use of various font families, including Helvetica, Arial, serif, sans-serif, cursive, monospace, and fantasy.
   - Each paragraph was styled with a different `font-family` value to showcase the appearance of these font styles.

Through these exercises, I gained a practical understanding of how different CSS font properties and units can be used to control the appearance of text on a webpage.

I learned about the significance of choosing the right font size, weight, and family for enhancing readability and the aesthetic appeal of web content. Additionally, it provided insight into how different units like pixels, points, em, and rem are used in defining font sizes and how they relate to each other and the parent or root elements.

## Day 45

### Projects (Day 45)

#### [45. 100 Movies You Must Watch](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-045/Projects/100%20Movies%20You%20Must%20Watch)

### Exercises (Day 45)

#### [A. Parsing HTML and Making Soup](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-045/Exercises/Parsing%20HTML%20and%20Making%20Soup)

In this exercise, I explored web scraping in Python using the BeautifulSoup library and requests module. The exercise was divided into two main parts.

First, I used `requests.get()` to fetch the HTML content of a webpage (in this case, Hacker News). By printing `response.text`, I was able to see the HTML structure of the webpage, which is essential for scraping data.

Next, the exercise focused on parsing local HTML content. This was done by reading a local HTML file named `website.html`, which contains a simple personal site structure. I used `BeautifulSoup` to parse this HTML content.

Several key functionalities of BeautifulSoup were demonstrated:

1. Accessing and printing the page title using `soup.title.name` and `soup.title.string`.
2. Formatting and viewing the prettified HTML structure with `soup.prettify()`.
3. Extracting the first anchor tag using `soup.a`.
4. Finding and iterating over all anchor tags with `soup.find_all(name="a")` to print their href attributes.
5. Locating specific elements by HTML tags and attributes, like `soup.find(name="h1", id="name")` for an `<h1>` tag with a specific id.
6. Using CSS selectors to find elements, such as `soup.select_one(selector="p a")` and `soup.select(selector=".heading")`.

Through this exercise, I learned how to scrape and parse web page data, manipulate HTML content, and extract specific information using BeautifulSoup's various methods. This is a foundational skill in web scraping, enabling the extraction of data from web pages for analysis or data gathering purposes.

#### [B. Scraping a Live Site](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-045/Exercises/Scraping%20a%20Live%20Site)

In this exercise, I learned to scrape live website data using BeautifulSoup and requests in Python. The primary objective was to extract article titles and their corresponding links from the Hacker News website.

Here's a breakdown of what I did:

1. **Fetching Web Page Content**: I used `requests.get("https://news.ycombinator.com/news")` to send an HTTP request to the Hacker News website and stored the response, which is the HTML content of the page, in `yc_web_page`.

2. **Creating a BeautifulSoup Object**: Next, I passed `yc_web_page` to `BeautifulSoup` with the parser `html.parser`. This created a BeautifulSoup object (`soup`) that represents the parsed HTML, making it easier to navigate and search the document structure.

3. **Selecting Specific Elements**: The goal was to find all article titles and their URLs. To achieve this, I used `soup.select(selector=".titleline > a")` to select all `<a>` tags that are direct children of elements with the class `titleline`. This CSS selector effectively targeted the links of the articles.

4. **Extracting Text and URLs**: I initialized two lists, `article_texts` and `article_links`, to store the titles and URLs, respectively. Then, I looped through the tags obtained in the previous step. For each tag, I used `tag.getText()` to get the article title and `tag.get("href")` to get the URL. These values were appended to the respective lists.

5. **Printing the Results**: Finally, I printed `article_texts` and `article_links` to see the extracted information.

This exercise was an excellent practice in live web scraping, particularly in using CSS selectors to precisely target HTML elements and extracting relevant information from a real-world website.

## Day 46

### Projects (Day 46)

#### [46. Billboard Hot 100 Playlist Creator - CLI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-046/Projects/Billboard%20Hot%20100)

## Day 47

### Projects (Day 47)

#### [47. Amazon Price Tracker](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-047/Projects/Amazon%20Price%20Tracker)

## Day 48

### Projects (Day 48)

#### [48. Cookie Clicker Automation](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-048/Projects/Cookie%20Clicker)

### Exercises (Day 48)

#### [A. Selenium Basics](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-048/Exercises/Selenium%20Basics)

In this exercise, I learned the basics of web automation using Selenium, a powerful tool for controlling web browsers through programs. The task involved interacting with the PyPI (Python Package Index) website to extract information about a specified Python package.

Here's what I did:

1. **Setting Up Selenium WebDriver**: I imported necessary modules from Selenium and set up Chrome WebDriver with certain options, including `chrome_options.add_experimental_option("detach", True)` to keep the browser window open after the script execution.

2. **User Input for Package Name**: I used `input()` to prompt for and capture the name of a Python package from the user. 

3. **Navigating to the Package Page**: Using `driver.get()`, I navigated to the specific page for the user-specified package on PyPI by appending the package name to the base URL.

4. **Extracting Package Information**: I used `driver.find_element()` with various CSS selectors to locate and extract information from the web page. This included the package's name, pip install command, release date, description, and maintainers. For maintainers, I used `driver.find_elements()` to gather multiple elements and then processed them into a list of maintainer names.

5. **Interacting with Elements**: I demonstrated how to interact with a button on the page (`copy_btn.click()`) and how to use the search function by sending keys to the search input field, including simulating an Enter key press with `Keys.ENTER`.

6. **Printing Extracted Data**: I formatted and printed the extracted data to the console, showing details like the package name, installation command, release date, description, and maintainers.

7. **Browser Control**: Although commented out, the code included options to either close the current tab (`driver.close()`) or the entire browser instance (`driver.quit()`).

Through this exercise, I gained hands-on experience in using Selenium for web scraping and automation. I learned how to navigate web pages, select elements based on their attributes, interact with page elements like buttons and input fields, and extract text data from a website. This is highly useful for tasks that require automation of browser activities, such as testing web applications, automating repetitive web tasks, or scraping data from websites that require interaction.

## Day 49

### Projects (Day 49)

#### [49. Color Madness Game](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-049/Projects/Color%20Madness)

## Day 50

### Projects (Day 50)

#### [50. Billboard Hot 100 Playlist Creator v2 Upgrade - GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-050/Projects/Billboard%20Hot%20100)

## Day 51

### Projects (Day 51)

#### [51. Billboard Hot 100 Playlist Creator v3 Upgrade - GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-051/Projects/Billboard%20Hot%20100)

## Day 52

### Projects (Day 52)

#### [52. Billboard Hot 100 Playlist Creator v4 Upgrade - GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-052/Projects/Billboard%20Hot%20100)

## Day 53

### Projects (Day 53)

#### [53. BMI Calculator v3 Upgrade - GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-053/Projects/BMI%20Calculator%20GUI%20App)

## Day 54

### Projects (Day 54)

#### [54. Create Your Own Python Decorator](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-054/Projects/Create%20Your%20Own%20Python%20Decorator)

### Exercises (Day 54)

#### [A. Introduction to Flask](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-054/Exercises/Introduction%20to%20Flask)

In this exercise, I got an introduction to Flask, a lightweight and powerful web framework for Python. Flask is widely used for creating web applications due to its simplicity and flexibility. Here's a summary of what I did and learned:

1. **Setting Up Flask**: I started by importing Flask from the flask module. This is the main class in Flask and is the backbone of any Flask application.

2. **Creating a Flask App Instance**: I created an instance of the Flask class. `__name__` is a special variable in Python that is used as an argument in the Flask class. It represents the name of the current Python module, which Flask uses to find resources, templates, and static files.

3. **Defining a Route**: I used the `@app.route("/")` decorator to tell Flask what URL should trigger the function that follows. In this case, the function `hello_world` is linked to the root URL ("/"). This is known as defining a route.

4. **Creating a View Function**: The `hello_world` function is a view function. When this route is accessed through a web browser or a HTTP request, this function gets executed. It returns a simple HTML string: `"<p>Hello, World!</p>"`.

5. **Running the App**: Finally, I used `app.run()` within the `if __name__ == "__main__":` block. This is a Python idiom that checks whether the script is executed as the main program and ensures that the Flask application runs only if the script is executed directly, not if it's imported as a module.

Through this exercise, I learned how to set up a basic Flask application. This included creating a Flask instance, defining routes with view functions, and running a simple web server. This is the foundation of web development with Flask, demonstrating how to serve web pages and handle routing in a Python application.

#### [B. Python Decorators](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-054/Exercises/Python%20Decorators)

In this exercise, I delved into the concept of Python decorators, which are a powerful and versatile feature in Python programming. Decorators allow for the modification or enhancement of functions without changing their actual code. Here’s a summary of what I did and learned:

1. **Defining a Decorator Function**: I created a decorator function named `delay_decorator`. This function takes another function as its argument (`function`) and defines a nested function inside it, called `wrapper_function`. 

2. **Functionality of the Decorator**: Inside `wrapper_function`, I added a delay of 2 seconds before calling the passed function, using `time.sleep(2)`. The passed function is then executed twice, demonstrating how decorators can modify the behavior of functions.

3. **Returning the Wrapper Function**: The `delay_decorator` function returns `wrapper_function` without executing it. This is key to how decorators work: they replace the original function with the wrapper function, which can then add additional behavior before or after the original function's execution.

4. **Applying the Decorator**: I used the decorator on three different functions (`say_hello`, `say_bye`, and `say_greeting`) to modify their behavior. The `@delay_decorator` syntax is a syntactic sugar in Python that simplifies the application of decorators.

   - For `say_hello` and `say_bye`, I applied the decorator directly using the `@` syntax.
   - For `say_greeting`, I demonstrated the decorator's use without the syntactic sugar by manually passing the function to `delay_decorator` and storing the returned function in `decorated_function`. This was then called like a regular function.

5. **Understanding Decorators**: Through this exercise, I gained a deeper understanding of decorators as functions that take another function as an argument, return a function, and are used to modify or extend the behavior of the original function in a non-intrusive manner.

#### [C. Python Functions](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-054/Exercises/Python%20Functions)

In this lesson on Python functions, I learned the following key concepts:

1. **Functions can have inputs, functionality, and outputs**:
   - Functions like `add`, `subtract`, `multiply`, and `divide` were defined with parameters (`n1` and `n2`) to accept input values. Each function performs a specific operation and returns the result using the `return` statement.

2. **Functions are first-class objects**:
   - Functions in Python are treated as first-class objects, which means they can be assigned to variables, passed as arguments to other functions, and returned from other functions. In the example, the `calculate` function takes another function as an argument, demonstrating how functions can be passed around.

3. **Nesting functions**:
   - Functions can be nested within other functions. In the `outer_function`, there is a nested `nested_function`. When `outer_function` is called, it prints "I'm outer" and then calls `nested_function`, which prints "I'm inner." This illustrates the concept of function nesting.

4. **Functions can be returned from other functions**:
   - The `outer_function` also demonstrates that functions can be returned from other functions. In this case, `outer_function` returns the `nested_function`, and it can be assigned to a variable (`inner_function`) and subsequently called.

Overall, this lesson introduced me to the versatility of functions in Python, showcasing their ability to accept inputs, perform operations, be passed as arguments, be nested, and even be returned from other functions. This understanding is fundamental for building modular and reusable code in Python.

## Day 55

### Projects (Day 55)

#### [55. Higher or Lower Dynamic Routes/URLs](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-055/Projects/Higher%20or%20Lower%20URLs)

### Exercises (Day 55)

#### [A. Advanced Decorators](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-055/Exercises/Advanced%20Decorators)

In this section, I explored advanced concepts of Python decorators, furthering my understanding of this powerful feature. Decorators are used to modify or extend the functionality of functions in Python. Here's what I did and learned:

1. **User Authentication Decorator**:
   - **Purpose**: I implemented a decorator named `is_authenticated_decorator` to check if a user is authenticated before allowing certain actions (like creating a blog post).
   - **Implementation**: This decorator takes a function as an argument and returns a nested function, `authenticate`. Inside `authenticate`, it checks if the first argument (assumed to be a user) is logged in. If so, it allows the function to execute.
   - **Usage**: I applied this decorator to a function `create_blog_post`, demonstrating its use by creating an instance of a `User` class and toggling their `is_logged_in` status. This showcased how decorators can be used for access control in applications.

2. **Logging Decorator Challenge**:
   - **Objective**: To create a logging decorator named `logging_decorator` that logs the details of function calls.
   - **Functionality**: This decorator wraps around a function and prints out the function's name, the arguments it was called with, and the result it returned.
   - **Application**: I applied this decorator to `a_function`, which performs a multiplication operation. The decorator effectively logged the call details, demonstrating its utility in debugging and monitoring function usage.

**Advanced Decorators - Key Learnings**:
- **Decorator Mechanics**: Both exercises reinforced the concept that decorators are functions that return other functions, allowing for dynamic modification of function behavior.
- **Practical Use Cases**: The user authentication decorator illustrated a practical use of decorators in managing access control, while the logging decorator highlighted their utility in logging and debugging.
- **Flexibility and Power**: These exercises showcased the flexibility and power of decorators in Python, demonstrating how they can be applied to a wide range of scenarios to add functionality to existing code in a clean and maintainable way.

Overall, these exercises deepened my understanding of decorators in Python, showing how they can be leveraged to write more efficient, cleaner, and more maintainable code.

#### [B. Flask Practice](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-055/Exercises/Flask%20Practice)

In this exercise, I practiced using Flask, a popular micro web framework in Python, to build a simple web server with various routes and decorators for HTML text formatting.

The script starts by importing `Flask` and creating a Flask app instance. Then, I defined three decorator functions, `make_bold`, `make_emphasis`, and `make_underlined`. Each of these decorators takes a function and wraps its output in HTML tags (`<b>`, `<em>`, and `<u>`, respectively) for bold, italic, and underlined text.

Next, I defined three routes using the `@app.route` decorator:

1. The root route (`"/"`) returns a basic HTML page with a heading, a paragraph, and an image. This route is a straightforward demonstration of serving HTML content with Flask.

2. The `"/bye"` route is decorated with the previously defined decorators to apply bold, italic, and underline formatting to its output. The layered use of decorators here showcases how to combine multiple decorators to enhance a function's output.

3. The `"/username/<name>/<int:age>"` route demonstrates Flask's ability to capture variable path segments. This route accepts a `name` (string) and `age` (integer) as URL parameters and displays them in a formatted string. This exemplifies how to dynamically respond to user input in URLs.

Finally, the script runs the app with `debug=True`, enabling the debug mode for easier development and troubleshooting.

Through this task, I continued to learn about Flask. Specifically expanding on: setting up a Flask applications, routing, dynamic URL parameters, HTML formatting in Flask, and the use of decorators to modify the behavior of functions. This exercise provided a practical foundation for web development with Flask.

## Day 56

### Projects (Day 56)

#### [56. Name Card Website](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-056/Projects/Name%20Card%20Website)

### Exercises (Day 56)

#### [A. Open Source Template](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-056/Exercises/Open%20Source%20Template)

In this exercise, I explored the basics of setting up a web application using Flask, a popular Python web framework, along with incorporating HTML templates and static assets. 

The Python script uses Flask to create a simple web server. The `Flask` class from the `flask` module is used to initialize the app, and the `render_template` function is employed to render HTML pages.

A route is defined using the `@app.route` decorator. The function `hello_world()` is linked to the root URL ("/"). When this URL is accessed, the function returns the rendered `index.html` template.

The `if __name__ == "__main__"` block checks if the script is executed directly (and not imported as a module in another script). If so, `app.run(debug=True)` starts the Flask application with debug mode enabled, allowing for real-time updates and detailed error logs.

The Flask application is configured to serve static assets from the `static/assets` folder, which is organized into subfolders for CSS, JavaScript, SASS, and webfonts. This structure is essential for managing various frontend components like stylesheets, scripts, and font resources.

The `templates/index.html` file is an HTML document that structures the web page. It includes references to the CSS stylesheet (`main.css`) and JavaScript files stored in the `static/assets` directory. The HTML template features sections like header, navigation, main content areas, and footer, showcasing different elements like images, links, and text blocks.

This setup demonstrates how to use Flask for serving dynamic web content, manage static files, and render HTML templates. It's a foundational step in web development with Python, showcasing how to structure a project, serve static assets, and create a basic web page layout.

#### [B. Resume Site Template](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-056/Exercises/Resume%20Site%20Template)

In this exercise, I created a personal resume website using Flask and HTML. The goal was to develop a web application that showcases a professional profile, including education, projects, technical skills, and contact information.

The Flask setup remained straightforward, with the application initialized and a single route defined. This route, mapped to the root URL ("/"), returns the rendered HTML page `resume.html` located in a subfolder `cv` within the `templates` directory. This structure illustrates how Flask can manage templates organized in subdirectories, offering a neat way to structure larger projects.

The HTML template `resume.html` is crafted as a personal resume. It begins with standard HTML document headers, including a link to a CSS stylesheet (`styles.css`) stored in the `static` folder. This CSS file presumably contains custom styles to enhance the visual appeal of the resume.

The body of the `resume.html` is structured to include various sections typical of a resume:

1. **Personal Information and Contact:** It starts with an image tag displaying a portrait (referenced from the `static` folder) and continues with basic contact information and social media links.

2. **Education:** This section lists academic qualifications, including the institution, graduation date, degree, and relevant coursework.

3. **Projects:** Several projects are detailed, each with a title, technologies used, and a brief description. This section highlights practical skills and experiences.

4. **Technical Skills:** A comprehensive list of technical skills, languages, libraries, frameworks, developer tools, certifications, and hobbies is provided.

The HTML structure of the resume is simple yet effective, using headings, paragraphs, lists, and divisions to organize the content. It demonstrates how to present detailed professional information in a clear, readable format on a web page.

## Day 57

### Projects (Day 57)

#### [57. Blog Site](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-057/Projects/Blog%20Site)

### Exercises (Day 57)

#### [A. Jinja Template Introduction](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-057/Exercises/Jinja%20Template%20Introduction)

In this exercise, I was introduced to using Jinja templates with Flask, a popular Python web framework. Jinja is a powerful template engine for Python, enabling dynamic content generation in HTML files.

The `server.py` file serves as the backbone of the application. It uses Flask to create web routes and serve HTML templates. The application includes three primary routes:

1. **Home Route ("/")**: This route generates a random number and the current year, passing them to `index.html` using Jinja's template syntax. The template dynamically displays these values.

2. **Guess Route ("/guess/<name>")**: This route takes a name as a parameter and tries to guess the age and gender of the person. It first checks if the data is already stored in a local JSON file (`data.json`). If not, it fetches the data using external APIs (`agify.io` and `genderize.io`), stores it in the JSON file, and then passes it to `demographics.html`. This demonstrates API interaction, file handling, and dynamic content rendering using Jinja.

3. **Blog Route ("/blog/<num>")**: This route fetches blog posts from an external API and displays a specific post in `blog.html` based on the passed ID. It showcases how to handle and display lists of data using Jinja.

The HTML templates (`index.html`, `demographics.html`, and `blog.html`) are designed to display the data passed from the server. They use Jinja's templating syntax (e.g., `{{ variable }}`, `{% for %}`, `{% if %}`) to embed Python-like expressions and control structures into the HTML, allowing for dynamic content rendering based on the server-side data.

Through this exercise, I learned how to:

- Set up a basic Flask application.
- Use routes to handle different URLs.
- Pass data from the server to the templates.
- Use Jinja's templating features to render dynamic content in HTML.
- Interact with APIs and handle JSON data.
- Perform basic file operations (read/write JSON).
- Utilize Flask's `url_for` function for generating URLs.

This was a practical introduction to web development with Flask and Jinja, highlighting how Python can be used to create dynamic, data-driven websites.

## Day 58

### Projects (Day 58)

#### [58. TinDog App Landing Page](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-058/Projects/TinDog%20Project)

### Exercises (Day 58)

#### [A. Bootstrap Introduction](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-058/Exercises/Bootstrap%20Introduction)

In this exercise, I've learned how to create a responsive card layout using Bootstrap, a popular CSS framework that helps design web pages quickly and efficiently. 

The `index.html` file is structured with a `<!DOCTYPE html>` declaration, followed by HTML5 elements structured with a `head` and a `body`. In the `head` section, Bootstrap's CSS file is included from a CDN (Content Delivery Network), which gives me access to Bootstrap's pre-defined classes for styling and responsiveness.

The style section within the `head` defines a `flex-container` class that uses Flexbox to center its contents both vertically and horizontally within the viewport height. This is a common design pattern for centering content, especially in a card-based layout.

In the `body`, the `flex-container` class is applied to a `div` element, which wraps around the Bootstrap card component. The card component is constructed using `div` elements with specific Bootstrap classes:

- `card`: This class defines the basic card structure.
- `card-img-top`: This class is used for the image at the top of the card.
- `card-body`: This class contains the content of the card, including a title (`card-title`), text content (`card-text`), and a button (`btn btn-primary`).

The image displayed on the card is referenced locally from `./flower.jpg`. The card's title, text, and button are defined with placeholder text and styled using Bootstrap's classes.

Finally, Bootstrap's JavaScript bundle is included just before the closing `body` tag. This bundle contains Bootstrap's JavaScript components, which can add interactive behavior to Bootstrap elements if needed.

In summary, I've learned how to:

- Include Bootstrap's CSS and JS files using a CDN.
- Utilize Bootstrap classes for styling and layout, such as cards and buttons.
- Implement Flexbox for centering content using custom CSS classes.
- Structure HTML for a Bootstrap card component with an image, title, text, and button.

By understanding these concepts, I can now create a visually appealing and responsive card layout that can be further customized as needed for web development projects.

#### [B. Bootstrap Components](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-058/Exercises/Bootstrap%20Components)

In this exercise, I applied Bootstrap components to build a comprehensive webpage for a moving service company, "Move It". Using Bootstrap 5, I created a user-friendly, responsive design that adapts to various devices.

Here's a breakdown of what I learned and implemented:

**Navigation Bar**: I incorporated a responsive navigation bar that includes the company logo and navigation links like 'Home', 'About', 'Services', and a search bar for postcode checking. Bootstrap's classes made it simple to create a collapsible menu for smaller screens.

**Hero Section**: For the hero section, I used a centered text layout with a call to action, introducing the site with a warm welcome message and offering quick access to 'Get a Quote' and 'Contact Us' buttons. This area is designed to make a strong first impression and drive user engagement.

**Features Section**: I showcased the company's key selling points in a three-column layout for larger screens, which collapses into a single column on smaller devices. Each feature is accompanied by an SVG icon and a brief description of services like 'Professional', 'Countrywide', and 'Personal Touch', highlighting the brand's values and services.

**Carousel**: I added a Bootstrap carousel to display multiple images that users can browse through. This interactive component can highlight different aspects of the service, such as family-friendly and pet-friendly moves.

**Footer**: The footer is structured with multiple columns, providing quick navigation links and mirroring the navigation bar's design. It reinforces the site's structure and offers additional resources for users.

**Styling**: Custom styles were added to adjust specific elements, such as the size of the SVG icons and the company logo. This ensures brand consistency and visual appeal throughout the site.

**Script Inclusion**: Bootstrap's JavaScript bundle is included at the end of the body to enable dynamic components like the carousel and collapsible navbar.

Through this exercise, I not only practiced implementing Bootstrap components but also enhanced my understanding of web design patterns and responsive layouts. I learned how to piece together different Bootstrap elements to create a cohesive and functional website, paying attention to both aesthetics and user experience.

## Day 59

### Projects (Day 59)

#### [59. Upgraded Blog](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-059/Projects/Upgraded%20Blog)

## Day 60

### Projects (Day 60)

#### [60. BMI Calculator v4 Upgrade - GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-060/Projects/BMI%20Calculator%20GUI%20App)

## Day 61

### Projects (Day 61)

#### [61. Flask WTForms](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-061/Projects/Flask%20WTForms)

## Day 62

### Projects (Day 62)

#### [62. Coffee & Wi-Fi Website - Accessing CSV](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-062/Projects/Coffee%20and%20Wi-Fi)

## Day 63

### Projects (Day 63)

#### [63. Library App - Accessing SQLite DB](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-063/Projects/Library%20App)

### Exercises (Day 63)

#### [A. SQLite Practice](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-063/Exercises/SQLite%20Practice)

In this exercise, I practiced using SQLite with Python to manage a simple database. SQLite is a C library that provides a lightweight disk-based database and allows for a self-contained, serverless, zero-configuration, and transactional SQL database engine.

Here’s what I learned:

1. **Database Connection**:
   I started by connecting to an SQLite database named `books-collection.db` using `sqlite3.connect`. This method returns a connection object.

2. **Creating a Cursor**:
   Using the connection object, I created a cursor object by calling `db.cursor()`. The cursor is used to execute SQL commands.

3. **Creating a Table**:
   I learned to create a new table named `books` with columns for `id`, `title`, `author`, and `rating`. The `id` is set as the PRIMARY KEY, which means each value must be unique and not null. The `title` and `author` are stored as strings (`varchar(250)`) and are not nullable, with the `title` also being unique. The `rating` is a floating-point number. The SQL command for creating a table is written as a string and executed by the cursor with the `execute` method.

   ```sql
   CREATE TABLE books (id INTEGER PRIMARY KEY, title varchar(250) NOT NULL UNIQUE, author varchar(250) NOT NULL, rating FLOAT NOT NULL)
   ```

   This command was commented out after the initial run because you only need to create the table once.

4. **Inserting Data**:
   I inserted a new row into the `books` table with values for each column. The SQL command for inserting is also a string executed by the cursor.

   ```sql
   INSERT INTO books VALUES(1, 'The Sixth Extinction', 'Elizabeth Kolbert', '9.8')
   ```

5. **Committing Changes**:
   After executing an insertion, I learned to commit the changes to the database using `db.commit()`. It's essential to commit after modifications, or the changes won't be saved.

6. **Handling Unique Constraints**:
   Since the `title` column is unique, I would need to handle exceptions if I tried to insert a book with a title that already exists in the database. This would raise an `sqlite3.IntegrityError`, which I would need to catch and handle appropriately.

Through this exercise, I understood the basics of SQLite database operations in Python, including connecting to a database, creating a table, inserting data, and committing changes. This knowledge is fundamental for any application that requires data persistence.

#### [B. SQLAlchemy Practice](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-063/Exercises/SQLAlchemy%20Practice)

In this exercise, I practiced how to use SQLAlchemy, an Object-Relational Mapping (ORM) library for Python, with a Flask application to interact with an SQLite database. Here's what I learned:

**Setting Up the Environment**:
- I initialized a Flask app and used the Flask-SQLAlchemy extension to integrate SQLAlchemy into the Flask app.
- Configured the app to connect to an SQLite database named `new-books-collection.db`.

**Creating a Database Model**:
- Defined a `Book` class as a model that represents a table in the database. The class inherits from `db.Model`.
- Specified columns for the table: `id`, `title`, `author`, and `rating`. Each column is an instance of `db.Column` with type and constraints (like `primary_key` and `nullable`) defined.

**Creating the Table**:
- Used the `db.create_all()` function within the Flask app's application context to create the table in the database according to the schema defined in the `Book` class.

**CRUD Operations**:
1. **Create (Commented Out)**:
   - Created a new book record with given values and added it to the session, then committed the session to save changes to the database.

2. **Read All Records (Commented Out)**:
   - Executed a query to select all books, ordered by title, and printed the result.

3. **Read a Specific Record by Query (Commented Out)**:
   - Executed a query to find a specific book by its title.

4. **Update a Record by Query (Commented Out)**:
   - Found a book by its title, updated its rating, and committed the changes.

5. **Update a Record by Primary Key (Commented Out)**:
   - Found a book by its `id`, updated its title, and committed the changes.

6. **Delete a Specific Record by Primary Key (Commented Out)**:
   - Found a book by its `id`, deleted it from the session, and committed the changes to remove it from the database.

Throughout this exercise, I learned how to:
- Set up and integrate SQLAlchemy with a Flask app.
- Define a model class with SQLAlchemy.
- Perform basic CRUD (Create, Read, Update, Delete) operations using SQLAlchemy ORM.
- Use Flask's application context to perform database operations.

The use of SQLAlchemy ORM allows for writing Pythonic code that translates to SQL queries, which abstracts away the complexity of direct SQL statements and provides a more readable, maintainable codebase. This is especially helpful in larger projects where database schemas and operations can become quite complex.

## Day 64

### Projects (Day 64)

#### [64. Favorite Movies Website](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-064/Projects/Favorite%20Movies%20Website)

## Day 65

### Projects (Day 65)

#### [65. Notes GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-065/Projects/Notes%20GUI%20App)

## Day 66

### Projects (Day 66)

#### [66. Cafe API - Flask REST API](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-066/Projects/Cafe%20REST%20API)

## Day 67

### Projects (Day 67)

#### [67. Blog API - Flask REST API](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-067/Projects/Blog%20REST%20API)

## Day 68

### Projects (Day 68)

#### [68. Flask Authentication](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-068/Projects/Flask%20Authentication)

## Day 69

### Projects (Day 69)

#### [69. Blog with Users & Authentication](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-069/Projects/Blog%20with%20Users)

## Day 70

### Projects (Day 70)

#### [70. Using Git/GitHub](https://github.com/itsjordanmuller/2023-python-100-days/tree/main#day-70)

The original purpose of this lesson was to start learning how to use Git for version control and GitHub for version control hosting. However, I started this project from Day 1 using Git/GitHub.

I might come back to this at some point to make a Git helper script/application using Python, but I decided to give myself a free pass for now since I've been using Git from Day 1!

## Day 71

### Projects (Day 71)

#### [71. Folder File Scanner](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-071/Projects/Folder%20File%20Scanner)

## Day 72

### Projects (Day 72)

#### [72. College Major Salary Data Exploration](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-072/Projects/College%20Major%20Salary%20Data%20Exploration)

## Day 73

### Projects (Day 73)

#### [73. Programming Language Analysis](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-073/Projects/Programming%20Language%20Analysis)

## Day 74

### Projects (Day 74)

#### [74. LEGO Data Analysis](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-074/Projects/LEGO%20Data%20Analysis)

## Day 75

### Projects (Day 75)

#### [75. Google Trends Data Analysis](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-075/Projects/Google%20Trends%20Data%20Analysis)

## Day 76

### Projects (Day 76)

#### [76. Google Play Store App Analytics](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-076/Projects/Google%20Play%20Store%20App%20Analytics)

## Day 77

### Projects (Day 77)

#### [77. NumPy & N-Dimensional Arrays](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-077/Projects/NumPy%20and%20N-Dimensional%20Arrays)

## Day 78

### Projects (Day 78)

#### [78. Linear Regressions & Seaborn](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-078/Projects/Linear%20Regressions%20and%20Seaborn)

## Day 79

### Projects (Day 79)

#### [79. Nobel Prize Analysis](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-079/Projects/Nobel%20Prize%20Analysis)

## Day 80

### Projects (Day 80)

#### [80. Distributions and t-Tests](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-080/Projects/Distributions%20and%20t-Tests)

## Day 81

### Projects (Day 81)

#### [81. Predict House Prices](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-081/Projects/Predict%20House%20Prices)

## Day 82

### Projects (Day 82)

#### [82. Morse Code Converter](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-082/Projects/Morse%20Code%20Converter)

## Day 83

### Projects (Day 83)

#### [83. Portfolio Site](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-083/Projects/Portfolio%20Site)

## Day 84

### Projects (Day 84)

#### [84. Tic-Tac-Toe vs Bot](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-084/Projects/Tic-Tac-Toe%20vs%20Bot)

## Day 85

### Projects (Day 85)

#### [85. Image Watermarking GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-085/Projects/Image%20Watermarking%20GUI%20App)

## Day 86

### Projects (Day 86)

#### [86. Typing Speed Test GUI App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-086/Projects/Typing%20Speed%20Test%20GUI%20App)

## Day 87

### Projects (Day 87)

#### [87. Breakout Game](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-087/Projects/Breakout%20Game)

## Day 88

### Projects (Day 88)

#### [88. Full Stack Coffee & Wi-Fi](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-088/Projects/Full%20Stack%20Coffee%20and%20Wi-Fi)

## Day 89

### Projects (Day 89)

#### [89. Todo List Site](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-089/Projects/Todo%20List%20Site)

## Day 90

### Projects (Day 90)

#### [90. Disappearing Text Writing App](https://github.com/itsjordanmuller/2023-python-100-days/tree/main/Day-090/Projects/Disappearing%20Text%20Writing%20App)

## Day 91

## Day 92

## Day 93

## Day 94

## Day 95

## Day 96

## Day 97

## Day 98

## Day 99

## Day 100

## Sources & Credits
Guided Exercises by [Angela Yu](https://www.udemy.com/user/4b4368a3-b5c8-4529-aa65-2056ec31f37e/)
